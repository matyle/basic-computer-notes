```cpp
class ab_base{
    public:
        virtual ~ab_base();
        virtual void interface() const = 0;
        virtual const char* mumble() const{
            return _mumble;
        }
    protected:
        char *_mumble;

}
```
- 抽象类，没有实体，但是有一个需要一个构造函数初始化_mumble
## 纯虚函数的存在

- 不要把虚析构函数声明为pure。

### 虚拟规格的存在

### 虚拟规格中的const
- 纯虚函数中不用const


### 重新考虑类的声明
- 析构函数不再是pure
- 纯虚函数不再是const

## 无继承的情况下对象构造

- 局部变量，全局变量，堆
<center>
    <img style="border-radius: 1.125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src=img/2021-06-02-21-34-25.png
width=490px>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>
- global是一个全局变量定义，未初始化，存放在BSS段中
- 局部类对象如果没有被初始化，可能会成为程序的

### 未继承做准备
- 虚函数的引入使得每个类对象都有一个虚表指针，导致了一个word的开销
- 引发编译器对于我们的Point class产生膨胀作用

### 继承体系下的对象构造
- T object实际会发生什么？

- 构造函数的隐藏码：
  - 1. 记录在成员初始化列表中的初始化操作会被放入构造函数本身，以成员声明顺序初始化
  - 2. 若有成员并未在初始化列表中，而有一个默认构造函数，则构造函数必须被调用
  - 3. 在这之前，类成员中的虚表指针，必须被设定初值，指向适当的虚表
  - 4. 在这之前，所有的基类构造函数必须被调用，以基类声明顺序为顺序
      - 若基类列于成员初始化列表中：任何明确指定的参数都应该传递过去
      -  基类没有被列于成员初始化列表中，，而它有默认构造函数或者默认成员式拷贝构造函数，那么就调用之
  - 5.  在那之前，所有虚基类构造函数必须被调用，从左到右，从最深到最浅
       - 如果类被列于成员初始化列表中，有任何明确到参数都应该传递过去。没有被列于成员初始化列表中，，而它有默认构造函数或者默认成员式拷贝构造函数，那么就调用之
       - 类中的虚基类子对象（subject）的偏移量必须在执行期被存取
       - 如果类对象是最底层的类，其构造函数可能被调用；

- 拷贝运算符：需要检查是否自我赋值，就直接删除对象是很危险的，那个对象很有可能是指向的自身


## 解构语义学

- 析构函数一层一层被调用