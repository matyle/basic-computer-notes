### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

**解决动态规划问题就是找「状态」和「选择」**。

状态：当前抢的房屋

选择：抢或者不抢



状态转移：

- 如果抢，则只能下次至少抢下下家，同时加上这次金额
- 不抢：可以抢下一家，但是这次没有金额

- 当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（**base case**）。

每次结果中选最大的

关于动态数组：

new int[] 是创建一个int型数组，数组大小是在[]中指定，例如：
int * p = new int[3]; //申请一个动态整型数组，数组的长度为[]中的值

new int()是创建一个int型数，并且用()括号中的数据进行初始化,例如：
int *p = new int(10); // p指向一个值为10的int数。



```cpp
方法一：自顶向下搜索
  
  

//自底向上
int dp[n+2];
memset(dp,0,sizeof dp);
for(int i=n-1;i>=0;--i)
{
  dp[i] = max(dp[i+1],dp[i+2]+nums[i]);//为什么从最后到前？更好算 从前面也可以
}
return dp[0];
```

