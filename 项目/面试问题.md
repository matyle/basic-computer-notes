
# 面试被问过的问题

* 介绍一下这个项目(几乎是必问的)

* 定时器是怎么实现的？还有什么实现方式？

  *   服务器程序通常要定期处理非活动连接:给客户端发送一个重连请求,或者关闭该连接。利用alarm函数周期性的触发SIGALRM信号， 该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时器任务---关闭非活动的连接。
  * 采用升序双向链表实现定时器的功能，核心函数tick,它每隔一端固定时间就执行一次，以检测并处理到期的任务。判断定时器任务到期的依据是定时器的expire值小于当前的系统时间。从执行的效率来看，添加定时器的时间复杂度是O(n), 删除定时器的时间复杂度是O(1),执行定时器任务的时间复杂度是O(1).

* 实现一个无锁队列(用原子操作或者cas)

  * 

* eventfd是什么？有什么好处？

  * eventfd用来触发事件通知，timerfd用来触发将来的事件通知。

* 双缓冲区异步日志是什么？为什么要这样做？对这个日志系统有没有进行压力测试？

* 什么是优雅关闭连接？(就是read()到0，要透明的传递这个行为而不是直接暴力close())

* epoll的边沿触发和水平触发有什么区别？(epoll的源码并不长，从源码的角度回答比较好)，水平触发和边沿触发在epoll中的实际实现，只是在传递这次事件之后，是否将此次的事件重新加回rdlist

  * 在epoll中使用ep_event_transfer()函数将rdlist中的事件拷贝到txlist 并清空rdlist
  * ep_event_send()函数将txlist中的事件拷贝到用户态，其中就会有判断
    * 
    * 如果重新加回rdlist，是水平触发（与时间相关，主动加入事件）
    * 如果不加回rdlist

* epoll为什么高效，相比select和poll

  * 用户态到内核态的拷贝降低为1次（实现了自己的文件系统）
  * poll和select每一次的循环都会将重新进程挂在fd对应等待队列上，而epoll只需要在epoll_ctl ADD一次（重复ADD相同fd不会生效），并挂好了设置回调函数，有事件会调用回调函数加入rdlist，而不是向poll每次循环遍历看事件有没有准备好
  * 将线性遍历整个监听事件降低为遍历rdlist
  * et模式更加高效（为什么？）
  * **有了EPOLLET，重复的事件就不会总是出来打扰程序的判断，故而常被使用。**那EPOLLET的原理是什么呢？

* HTTP报文都有哪些字段？

* 假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)

* 有没有实现内存池？

* 一个请求到来具体的处理过程是怎样的？

* 线程的唤醒还有哪些方式？

  * eventfd

* 怎么检查内存泄漏的？

* 用到了哪些智能指针和RAII机制，几种锁的区别是什么

* 任务队列是怎么实现的，除了加锁还有什么方式？

* 如何解决死锁？

* 怎么进行压测的？

  * webbench

* 为什么要用非阻塞io？

  * 比阻塞IO更加高效
  * et模式只能用非阻塞io

* 为什么要做这个项目？

  

* Reactor模式是什么？

基于事件驱动的设计模式，拥有一个或多个并发输入源，有一个服务处理器和多个请求处理器，服务处理器会同步的将输入的请求事件以多路复用的方式分发给相应的请求处理器。