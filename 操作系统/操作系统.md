### 第一章 

#### 处理器
- 寄存器
  - 通用寄存器：保存变量和临时变量
  - 程序计数器：它保存下一条指令的内存地址
  - 堆栈指针：
  - 程序状态字寄存器：

- 系统调用
  - 陷入内核并调用操作系统 Trap指令把用户态切换到内核态
  - 计算机使用陷阱而不是一条指令来执行系统调用，多数陷阱是硬件引起的
- 多线程
- 内存
  - 大端: 将高位字节存储在低地址，低位字节存储在高地址 从左往右，低到高
  - 小端： 将低位字节存储在低地址，高位字节存储在高地址 （和自然反的）
  - 一般网络字节序为大端字节序，主机字节序为小端。
  - 为什么会有大端小端？对于计算机来说， 对于数据从低位开始计算更容易，所以一般计算机内部都是小端字节序
```cpp
htonl()--"Host to Network Long"
ntohl()--"Network to Host Long"
htons()--"Host to Network Short"
ntohs()--"Network to Host Short"
```
  - 
- 磁盘
  - 磁盘调度算法
    - 先来先服务
    -  最短寻道时间优先：优先调度与当前磁头所在磁道距离最近的磁道。不公平，会产生饥饿现象
    -  电梯扫描算法：电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。  解决了 SSTF 的饥饿问题。
- I/O设备
- 中断
  - 一旦cpu决定取中断（关中断？），程序计数器和PSW压入栈中
  - read系统调用
  - 多道程序系统是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行 (系统由一个程序转而运行另一个程序时需要使用中断机构中断正在运行的程序) 。 两个或两个以上程序在计算机系统中同处于开始和结束之间的状态，这就称为多道程序系统。其技术运行的特征：多道、宏观上并行、微观上串行。


### 第二章 进程与线程

#### 2.1 进程
计算机所有可运行的软件，操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个 **正在执行的程序的实例**
生动描述：
程序和进程的区别：程序就像食谱，是使用适当形式描述的算法，厨师是cpu，而原材料输入数据等。而进程是厨师执行食谱等一系列动作等总和。

正在做菜的时候，突然厨师的儿子哭着跑进来说摔倒了，这时厨师会记录下食谱做到哪里了（保存进程状态，上下文，pc，寄存器内容，内存），然后拿着急救册，按其指示处理伤口。处理完然后从离开时记录的食谱继续做
- 进程模型
  - 单核情况下，一个进程都有自己的逻辑程序计数器，但是物理程序计数器只有一个
  - 进程是某种类型的一个活动，有程序，输入，输出以及状态。多个进程之间用某种调度算法来协调各个进程之间的运行
  - 进程是系统进行资源调度和分配的基本单位，实现操作系统的并发
  - 并发 微观上还是串行


- 进程创建
  - 创建的几种情况
    - 系统初始化：启动系统的时候创建若干进程
    - 执行了正在运行的进程所调用的系统调用；
    - 用户请求创建一个进程。
    - 一个批处理作业的初始化
  - 进程终止
    - 正常退出，错误退出，严重错误（非自愿），被其他进程杀死（非自愿）
- 进程的状态
  - 运行态，就绪态， 阻塞态
  - 只能从运行态到阻塞态，就绪态和运行态可以互转，阻塞态只能到就绪态
  
- 进程的实现
  - 维护一个表格（一个结构数组） 进程表 即进程控制块

#### 2.2线程
  - 线程是进程的子任务
  - 是cpu调度和分派的基本单位

|  进程  |  线程  |
|----|----|
|   资源调度和分配的基本单位 |  cpu调度和分配的基本单位  |
|   自己的系统资源空间 |  不拥有系统资源，只有程序计数器,一组寄存器和栈  |
| 一个进程可以包含若干个线程  |  一个线程只能属于一个进程 |
|进程需要以通信的方式进行|由于共享同一进程的资源，通信更加方便|
| 进程编程调试可靠性高，但是创建销毁的开销很大 |  开销小但是编程调试较为复杂。 |

![](/img/2021-04-07-19-52-02.png)

  - 进程与进程之间相对独立
![](/img/2021-04-07-19-52-36.png)

- 进程间的通信

|  通信方式  |  描述  |
|----|----|
|  管道(pipe)  |  允许一个进程和另一个与它有共同祖先的进程之间进行通信  |
|   命名管道(FIFO) | 类似于管道，但是它可以用于任何两个进程之间的通信,消息队列是消息的连接表|
|信号量(semaphore)|信号量主要作为进程间以及同进程不同线程之间的同步手段；|
|共享内存(shared memory)|是最快的可用IPC形式。|
|信号(signal)|用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身|
|Socket|更为通用的进程间通信机制，可用于不同机器之间的进程间通信|

- 线程间的通信

|  通信方式  |  描述  |
|----|----|
|  信号  | 类似进程间的信号处理   |
|  锁机制  | 互斥锁、读写锁和自旋锁   |
|  条件变量  |  使用通知的方式解锁，与互斥锁配合使用  |
| 信号量  |  包括无名线程信号量和命名线程信号量  |

### 进程调度

- 算法
  1. 先来先服务
  2. 段作业优先 对预计处理时间短的作业优先分配资源
  3. 轮转法 让每个进程在就绪队列中等待的时间与享受服务时间成正比例
  4. 多级反馈队列 设置多个就绪队列分别赋予优先级，较高的优先级队列分配较少的时间片
  5. 最短时间优先
  6. 优先级调度 为每个进程分配一个优先级，按优先级进行调度。

- 一个进程可以创建多少线程，和什么有关？
  - 一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的建立就会成功。
- 死锁的条件
  1. 互斥
  2. 占有和等待
  3. 不可抢占
  4. 环路等待
- 死锁的解决策略
  1. 鸵鸟策略
  2. 死锁检测和恢复
     1. 抢占资源
     2. 回滚恢复
     3. 杀死进程
  3. 死锁预防
     1. 破坏互斥条件
     2. 破坏占有等待条件
     3. 破坏不可抢占条件
     4. 破坏环路等待：给资源编号 进程只能按编号顺序来请求资源。
  4. 死锁避免：银行家算法
  
#### 协程

- `协程是用户态的一种轻量级线程，协程拥有自己的上下文和栈，协程调度时可以把上下文和栈保存在其他地方，协程能保留上一次调用时的状态，再次运行时能直接进入上次的状态。`

- 协程的优点：
  - 无需线程上下文切换开销
  - 无需原子操作锁定及同步开销
  - 方便切换控制流，简化编程模型
- 线程之间什么是共享的，什么是不共享的？
  - 堆，全局变量，静态变量是共享的。栈与寄存器是不共享的。
- 一个进程启动时的内存管理是怎样的？
- 僵尸进程和孤儿进程
  - 僵尸进程：子进程退出后需要父进程的确认收到才能在进程表中删除，而如果在自己成退出后，父进程并没有对其消亡进行确认，该进程就保存进程表中，占用资源。
    - 可以使用ps aux | grep Z查看当前的僵尸进程。
    - 使用kill -s SIGCHLD pid删除该父进程的所有僵尸进程
- 孤儿进程：当父进程死亡后，进程就变为了孤儿进程，由init进程代为收养。同时由init进程对其资源释放。
- 父进程如何知道子进程的存亡， 子进程如何知道父进程的存亡？
  - 父进程可以使用waitpid查看子进程是否已经销毁，当其子进程销毁后，父进程会收到SIGCHD信号。子进程只需查看其ppid是否是1，也就是其父进程是否是init，是否被init收养。

#### 守护进程
指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等。
- 创建守护进程
  - 让程序在后台执行。方法是调用fork（）产生一个子进程，然后使父进程退出。
  - 调用setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用setsid（）使进程成为一个会话组长。setsid（）调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。
  
  - 禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过fork（）创建新的子进程，使调用fork的进程退出。
  
  - 关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。

  - （5）将当前目录更改为根目录。

  - （6）子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask（0）将屏蔽字清零。

  - （7）处理SIGCHLD sigchid信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。

##### copy-on-write 写时复制

`写时复制是一种优化策略，当存在多个调用者请求相同资源时， 他们会共同获取相同的指针指向内存上的资源，而不是直接复制一份，仅当调用进程有写入需求时，操作系统才会真正的去分配一块资源来复制一份副本进行写入改动。`

##### 管道和套接字的区别
- 管道：在进程内通信最简单，有不同进程间不能实时知道管道描述符号，所以不太适合进程间直接通信，除非解决这个文件描述符号的传递才能实现进程间通信。
- socket:实现较复杂，可以实现各种情况下的进程间通信，要注意处理socket的服务端端口号的问题。

##### 信号量的具体原理

- 信号量是为了进程的互斥与同步，多个进程通过相互传递信号进行合作，发明的一种信号设施。其本质就是一个整数，当有进程想要使用该资源，就将通知信号量-1，再进行使用，使用结束后将信号量加回去，当发现信号量小于零时就代表没有资源可用，将进程挂起等待资源释放后在进行使用。否则直接进行使用无需等待。

##### 多进程架构与多线程架构有什么区别？

![](/img/2021-04-17-21-14-50.png)


##### 操作系统实现锁的方法

1. 关中断
2. test and set
3. compare and swap


- OS中的有的锁
  - 互斥锁 mutex
  - 读写锁：读写锁是一种 读共享，写独占的锁。
    - 当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会阻塞（不是失败）。  
    - 当读写锁被加了读锁时，其他线程对该锁加写锁会阻塞，加读锁会成功。
  - 自旋锁：自旋就是在共享资源的状态不满足时， 自旋锁持续不停的检测状态，它和其他锁的区别就在于不会使线程休眠，也就是不会产生上下文切换，但是会浪费cpu。

#### 内存管理

##### 分页管理
- 页式管理的基本原理是将各进程的虚拟空间划分为若干个长度相等的页
- 把内存空间按页的大小划分为片或者页面，然后把页式虚拟地址与内存地址建立一一对应的页表，并用相应的硬件地址转换机构来解决离散地址变换问题
##### 分段管理

##### 虚拟内存



### Linux

- 常见命令
```md
ps 查看进程

free 显示内存状态

df 显示磁盘分区上的磁盘空间的占用情况， 可以查看磁盘占用了多少空间，还能使用多少空间

du 显示每个文件和目录的磁盘使用空间，文件的大小

netstat 显示网络状态

tcpdump 抓包工具

ipcs 检查系统上共享内存等IPC的分配

ipcrm手动解除系统上共享内存的分配

ln 建立链接 -s为软连接 否则为硬链接

free 可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。
```

#### 系统调用的过程

1. 程序通过调用函数库中的外壳函数，发起系统调用
2. 函数将通过堆栈传入外壳函数的参数置入指定的寄存器。
3. 将系统调用的编号复制到EAX
4. 外壳函数执行中断指令0x80，处理器从用户态进入到内核态
5. 内核调用system_call
   1. 在内核栈中保存寄存器的值
   2. 审核系统调用编号的有效性
   3. 以编号索引找到对应的系统调用服务，并执行
   4. 从内核栈恢复寄存器的值，将系统调用返回值置于栈中

#### 文件系统

1. 用户空间， 用户可见的文件系统， 也就是常见的一些文件操作
2. 内核空间， 内核空间使用VFS系统屏蔽底层不同文件系统的实现，为上层提供统一的接口方便内核中系统调用。这也是体现linux一切皆文件的最重要的一层。
3. 物理设备层。

- 操作系统将磁盘分为两个区域，一个是数据区， 用来存储文件的具体数据，一个是inode table区，用来存储具体文件的索引表，就是inode table。

- 为了加速文件检索的速度和节省物理空间，linux使用inode来存储每个文件的所有信息以及物理存储位置。

```c
struct inode {
        struct hlist_node       i_hash;              /* 哈希表 */
        struct list_head        i_list;              /* 索引节点链表 */
        struct list_head        i_dentry;            /* 目录项链表 */
        unsigned long           i_ino;               /* 节点号 */
        atomic_t                i_count;             /* 引用记数 */
        umode_t                 i_mode;              /* 访问权限控制 */
        unsigned int            i_nlink;             /* 硬链接数 */
        uid_t                   i_uid;               /* 使用者id */
        gid_t                   i_gid;               /* 使用者id组 */
        kdev_t                  i_rdev;              /* 实设备标识符 */
        loff_t                  i_size;              /* 以字节为单位的文件大小 */
        struct timespec         i_atime;             /* 最后访问时间 */
        struct timespec         i_mtime;             /* 最后修改(modify)时间 */
        struct timespec         i_ctime;             /* 最后改变(change)时间 */
        unsigned int            i_blkbits;           /* 以位为单位的块大小 */
        unsigned long           i_blksize;           /* 以字节为单位的块大小 */
        unsigned long           i_version;           /* 版本号 */
        unsigned long           i_blocks;            /* 文件的块数 */
        unsigned short          i_bytes;             /* 使用的字节数 */
        spinlock_t              i_lock;              /* 自旋锁 */
        struct rw_semaphore     i_alloc_sem;         /* 索引节点信号量 */
        struct inode_operations *i_op;               /* 索引节点操作表 */
        struct file_operations  *i_fop;              /* 默认的索引节点操作 */
        struct super_block      *i_sb;               /* 相关的超级块 */
        struct file_lock        *i_flock;            /* 文件锁链表 */
        struct address_space    *i_mapping;          /* 相关的地址映射 */
        struct address_space    i_data;              /* 设备地址映射 */
        struct dquot            *i_dquot[MAXQUOTAS]; /* 节点的磁盘限额 */
        struct list_head        i_devices;           /* 块设备链表 */
        struct pipe_inode_info  *i_pipe;             /* 管道信息 */
        struct block_device     *i_bdev;             /* 块设备驱动 */
        unsigned long           i_dnotify_mask;      /* 目录通知掩码 */
        struct dnotify_struct   *i_dnotify;          /* 目录通知 */
        unsigned long           i_state;             /* 状态标志 */
        unsigned long           dirtied_when;        /* 首次修改时间 */
        unsigned int            i_flags;             /* 文件系统标志 */
        unsigned char           i_sock;              /* 可能是个套接字吧 */
        atomic_t                i_writecount;        /* 写者记数 */
        void                    *i_security;         /* 安全模块 */
        __u32                   i_generation;        /* 索引节点版本号 */
        union {
                void            *generic_ip;         /* 文件特殊信息 */
        } u;
};
```

#### 网络编程

##### 服务端编程API
```cpp

```