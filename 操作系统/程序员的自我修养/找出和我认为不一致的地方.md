- EBP栈中存的是调用者函数栈底地址的旧值，因此argc的地址应该是%ebp+4,&argv[0]=%ebp+8 (414页说的是ebp-4,ebp-8)

- 首先是 push    %ebp。当前%ebp保存的是调用者栈帧的栈底地址，那么push    %ebp就是将调用者栈帧的栈底地址压入栈，即保存旧的%ebp。
- 
- 接着是mov    %esp,%ebp。我们刚刚把旧的%ebp的值保存了下来，但是%ebp值并没有发生改变，而我们现在调用了一个新的函数，那么%ebp保存的应该是新的栈帧的栈底。所以才把当前%esp储存的地址赋值给%ebp。（这里说明一下，对于每一次push操作，%esp储存的地址会-1）。那么这样一来的话，相当于调用者栈帧的栈顶现在作为了新的栈帧的栈底（并且该栈底保存的是调用者栈帧的栈底地址，请记住这一点）。而此时新的栈帧的栈底和栈底位于同一个位置。


- 






