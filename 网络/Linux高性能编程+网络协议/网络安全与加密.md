[网络安全和加密-lvyilong316-ChinaUnix博客](http://blog.chinaunix.net/uid-28541347-id-5852362.html)

## 发展

远古时代：http明文不加密，民风淳朴，路不拾遗，夜不闭户。

HTTP不安全

- http 使用明文

- http 无验证

- http 无法报文完整性证明

  

上古时代：使用加密

中古时代：加密更近一步，但是还是会被拦截密钥

现代：

- 利用两对密钥，非对称密钥（仍然有安全隐患，修改密文内容和拦截替换公钥）
- 验证数据完整性（摘要-数字证书）
- 验证身份（CA证书）
- 每次连接非对称太浪费。非对称只用来传输对称密钥





### 远古时代

远古时代自然是民风淳朴，路不拾遗，夜不闭户。A要发数据给B，根本不用担心窃听和篡改，直接发就好了

都很纯洁没有监听



### 上古时代-对称加密算法

C不仅会监听A和B之间的网络数据，还会拦截A和B之间的数据，伪造之后再发给A或者B，进而欺骗A和B。C就是中间人攻击（Man In The Middle Attack）

什么是对称？

- **加密解密用的是同一个密钥**

为了应对C的攻击，A和B开始对自己的数据进行加密。A和B会使用一个共享的密钥，A在发送数据之前，用这个密钥对数据加密。B在收到数据之后，用这个密钥对数据解密。

DES（Data Encryption Standard）

采用了DES，A和B现在不用担心数据被C拦截了。因为就算C拦截了，也只能获取加密之后的数据， 没有密钥就没有办法获取原始数据。

- 问题1：共享密钥被破解

- 问题2：共享密钥可能被拦截
  - 有点像小时候的悄悄话 商量
  - 首先AB不能通过网络来传递密钥，因为密钥确定以前，所有的网络通信都是不安全。如果通过网络传递密钥，密钥有可能被拦截。拦截了就没有加密的意义了。为了安全，A和B只能先见一面，私下商量好密钥，这样C就没办法获取密钥。如果因为任何原因，之前的密钥泄露了，那么AB还得再见一面，重新商量一个密钥。

现在A和B之间，最私密的信息就是这个密钥了，只要保证密钥的安全，那么AB之间整个网络通信都是安全的，如何保证密钥安全？





### 中古时代

A和B小心的保护着密钥，不让C知道。

关于问题1：被破解

C找了一个好点的计算机，尝试每一个可能的值，这样总能找到一个密钥破解A和B之间的加密信息。于是出现了新的密钥

- triple-DES（最长168bit的密钥）

- **AES**（最高256bit的密钥）（基本破解不了了）

因此只剩问题2，如何不被在网络中拦截密钥？A和B还是需要见面商量一个密钥。



### 现代

#### 非对称加密

时间到了现代。网络通信变得十分发达，A不只与B通信，还同时还跟其他10000个人进行网络通信。A不可能每个人都跑去跟他们见个面，商量一个密钥。

- 非对称加密
  - **非对称加密使用两个密钥，一个是public key，一个是private key。通过一个特殊的数学算法，使得数据的加密和解密使用不同的密钥。因为用的是不同的密钥，所以称为**非对称加密 。
  - 例如：可以想象成一把钥匙（private key）和一个锁头（public key），只是全世界只有你一个人有这把钥匙（private key），你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。
  - **如果使用非对称加密，一般遵从这样的原则：公钥只用来加密，私钥只用来解密**

非对称加密最著名的是**RSA**算法，这是以其发明者Rivest, Shamir 和Adleman命名。

非对称加密的优点

- **如果使用非对称加密，一般遵从这样的原则：公钥只用来加密，私钥只用来解密**
- 私钥不会在公网上传播，因此，**私钥也可以认为是个人身份的证明**。

- A保留private keyA，首先传递公钥public keyA给B（让B发送数据给A时用公钥A加密）。B可以保留private keyB，传递公钥public keyB给A（让A用公钥B加密数据发送给B）。（需要两对密钥

- ![img](http://blog.chinaunix.net/attachment/202107/25/28541347_1627219137mCcy.png)

  此时C就算有公钥也无法解密

  

  这时有两个问题：

  - C可以修改密文
  - C可以获得A和B两个人的公钥 就能拿来干事情了吧？（替换）

因此我们要确认两个东西：

1. A的身份认证（确保消息是A发出的，有可能是替换了C的公钥）

2. A发送的消息完整性（确保消息没有被其他人篡改）

### 数字签名

要解决这个问题就要引入一个概念——**数字签名**。要将数字签名，还需要先了解另一个概念——**消息摘要**。

- 消息摘要：验证消息完整性
  - 经过哈希计算之后长度固定，值唯一
  - **该过程不可逆**，即不能通过摘要反推明文
  - SHA1（据说被破解了）和SHA2

- 使用将摘要（摘要不能反推原文）进行加密

![img](http://blog.chinaunix.net/attachment/202107/25/28541347_1627219150Gxx4.png)

- 数字签名

  即：**仍然公布公钥，但是用你的私钥加密数据，然后把加密的数据公布出去，这就是数字签名**。

  数据接收方B只需要用A的公钥解密对比是否修改，同时看是否是A发送的。
  你的私钥加密的数据，只有你的公钥才能解开，那么如果一份加密数据能够被你的公钥解开，不就说明这份数据是你（私钥持有者）本人发布的吗？

  

但是我们忽略了一个大问题：万一这个公钥本身就不是A的呢？C如果在一开始就替换了其中的公钥。那么所有数据C不就能用它自己的私钥解密吗？

### 非对称加密安全隐患

第二个问题还是没解决

如果C从一开始就截取了公钥

- 假设有这种情况，C拦截了A和B的public key，又分别用自己的public key发给A和B。A和B并不知道，他们还以为这个public key来自对方。
  - A先用自己的private key加密数据的hash值（为了让B知道发送用什么公钥），之后用C传来的假的public key加密数据，再发出去。C拦截到之后，先用C自己的private key解密数据，C就获取了A的原始信息
  - C可以篡改数据内容，再用自己的private key加密数据的hash值，用之前拦截的B的public key加密数据，再发给B。
  - B收到以后，先用自己的private key解密数据，再用C传来的假public key解密hash值，发现匹配。这样，B收到了一条来自C的假的信息，但是B还以为信息来自于A。



CA证书出场

  公钥加密的信息必须由对应的私钥才能解密，

同样，私钥做出的签名，也只有配对的公钥才能解密。（私钥加密）

公钥有时用来传输对称密钥，这就是数字信封技术。密钥的管理政策是把公钥和实体绑定，由CA中心把实体的信息和实体的公钥制作成数字证书，证书的尾部必须有CA中心的数字签名

- **B会先把自己的public key（和一些其他信息）交给CA。CA用自己的private key加密这些数据，加密完的数据称为B的**数字证书**。
- CA证书不在网络中流通，而是集成在浏览器和系统（盗版仍然可能被攻击）



这时，现在A和B都有了CA认证的数字证书。在交换public key的阶段，直接交换彼此的数字证书就行。而中间人C，还是可以拦截A和B的public key，也可以用CA证书解密获得A和B的public key。但是，C没有办法伪造public key了（知道是假的了）。

### SSL/TLS的应用

对称加密算法比对称加密算法要复杂的多，处理起来也要慢得多。

因此网络中不可能所有连接都使用非对称加密

非对称加密只会用来传递一条信息，那就是用于对称加密的密钥（SHA2）。当用于对称加密的密钥确定了，A和B还是通过对称加密算法进行网络通信。这样，既保证了网络通信的安全性，又不影响效率，A和B也不用见面商量密钥了。



SSL/TLS的过程

- **l** **通过CA体系交换public key**

- **l** **通过非对称加密算法，交换用于对称加密的密钥**

- **l** **通过对称加密算法，加密正常的网络通信**



#### HTTPS



HTTPs也叫：

HTTP over TLS。TLS（传输层安全transport layer security）的前身是SSL（安全套接字层secure socket layer），TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。

![img](http://blog.chinaunix.net/attachment/202107/25/28541347_1627219188iG47.png)



核心问题是记住**SSL/TLS是工作在TCP之上的（http之下的）。**

![img](http://blog.chinaunix.net/attachment/202107/25/28541347_1627219200SXLz.png)



#### http和htpps的区别

HTTPS解决的问题

- 信息加密传输：第三方无法窃听；
- 校验机制：一旦被篡改，通信双方会立刻发现；
- 身份证书：防止身份被冒充。

#### https的过程

首先是正常的三次握手

1. 客户端请求服务器获取`证书公钥`
2. 客户端(SSL/TLS)解析证书（无效会弹出警告）
3. 生成随机值
4. 用`公钥加密`随机值生成**密钥**
5. 客户端将`秘钥`发送给服务器
6. 服务端用`私钥`解密`秘钥`得到随机值
7. `将信息和随机值混合在一起`进行对称加密
8. 将加密的内容发送给客户端
9. 客户端用`秘钥`解密信息

![https.png](网络安全与加密.assets/1240.png)

![img](http://blog.chinaunix.net/attachment/202107/25/28541347_1627219215Q6yA.png)









## **常见加密算法和****AES**

常见的对称加密算法有：DES、AES、ChaCha20-Poly1305等。

常见的非对称加密算法有：RSA、DSA、ECDSA、 DH、ECDHE等。

