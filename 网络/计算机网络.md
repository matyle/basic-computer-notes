### 第一章 概述

- 七层模型
  - 应用层，表示层(数据加密或者压缩)，会话层，传输层，网络层，链路层，物理层
- 五层模型TCP/IP 重点协议或设备
  - 应用层，传输层，网络层，链路层，物理层
    - 应用层：`http(tcp)`,`DNS(udp)`,`FTP`,
    - 传输层（端到端）：`tcp` `udp`
      - TCP中三次握手，四次挥手
    - 网络层：`ip`，路由器
    - 链路层
    - 物理层

- 例子：
  - url到页面加载的过程？
    - 利用DNS查询服务器IP地址
      - 浏览器缓存->系统缓存->路由器缓存->ispDNS缓存->递归搜索IPS DNS服务器和顶级域名服务器
    - 通过TCP**三次握手**协商来建立一个 TCP/IP 连接
    - 浏览器通过TCP/IP连接向web服务器发送一个 HTTP 请求数据包，包含资源路径，身份信息
    - 服务器响应请求
### 应用层

#### HTTP
- http主要方法
  - GET：请求指定页面信息，并返回具体内容，读取数据
  - POST：指定资源提交数据并进行处理请求，数据被包含在请求体中,返回201表示创建成功
  - HEAD:跟GET差不多，区别就是不返回Body内容，只返回HTTP头信息。一般用于获取资源的元信息，比如长度，修改时间等
  - PUT 用于修改资源，比如修改资源的某个具体属性。
  - DELETE 用于删除资源。
  
- GET与POST的区别 
    - 安全性
      - 网上大部分文章的解释，POST 比 GET 安全，因为数据在地址栏上不可见。
      - 从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。
      - HTTPS加密更为安全。
  - GET 方法的长度限制是怎么回事？
    - HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。
    - 服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。
  - GET方法是幂等，POST不是幂等的
  - GET只支持ASCII码字符格式参数，post没有限制
  - 报文上：GET 和 POST 方法没有实质区别，只是报文格式不同。
    - 不带参数时：
      - 1. GET方法请求报文第一行是这样的 `GET /uri HTTP/1.1 \r\n`
      - 2. POST方法请求报文第一行是这样的 `POST /uri HTTP/1.1 \r\n`
    - 带参数时：
```js
GET /index.php?name=qiming.c&age=22 HTTP/1.1
Host: localhost

简略版
```
POST报文
```js
POST /index.php HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
​Content-Length: 2323(GET请求因为没有Body，所以不需要这个头)
name=qiming.c&age=22
```





- HTTP请求报文
```js
CURL curl命令
1. curl -s -v -H "Frank: xxx" -- "https://www.baidu.com"
2.curl -X POST -s -v -H "Frank: xxx" -- "https://www.baidu.com"
3.curl -X POST -d "1234567890" -s -v -H "Frank: xxx" -- "https://www.baidu.com"

GET方法 curl -s -v -H "Frank: xxx" -- "https://www.baidu.com"
请求报文 
> GET / HTTP/1.1
> Host: www.baidu.com
> User-Agent: curl/7.71.1
> Accept: */
> Frank: xxx 

2.curl -X POST -s -v -H "Frank: xxx" -- "https://www.baidu.com"
请求报文
POST / HTTP/1.1
Host: www.baidu.com
User-Agent: curl/7.54.0
Accept: */
Frank: xxx

3.curl -X POST -d "1234567890" -s -v -H "Frank: xxx" -- "https://www.baidu.com"
请求报文
POST / HTTP/1.1                                    上传信息
Host: www.baidu.com
User-Agent: curl/7.54.0
Accept: */
Frank: xxx
Content-Length: 10                                 上传的长度
Content-Type: application/x-www-form-urlencoded    上传的格式

1234567890
```
  - 请求的格式
```md
1 动词 路径 协议/版本
2 Key1: value1
2 Key2: value2
2 Key3: value3
2 Content-Type: application/x-www-form-urlencoded
2 Host: www.baidu.com
2 User-Agent: curl/7.54.0
3 
4 要上传的数据
分为四部分
第一部分的动词有GET(获取）POST(上传）PUT（整体更新）PATCH(部分更新）DELETE（删除）HEAD、OPTIONS.路径就是一个字符串，以/开头
第二部分是告诉给服务器信息。
第三部分永远都是一个“回车”，作用是区分第二部分和第三部分。
第四部分是上传的内容，密码头像等等。
```
![](/img/2021-04-15-13-31-48.png)
```md
- connection: keep-Alive (表示持续链接，多个http会话使用同一个TCP链接) 

```
- HTTP响应报文
```js
HTTP/1.1 200 OK
Accept-Ranges: bytes
Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
Connection: Keep-Alive
Content-Length: 2443
Content-Type: text/html
Date: Tue, 10 Oct 2017 09:14:05 GMT
Etag: "5886041d-98b"
Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT
Pragma: no-cache
Server: bfe/1.0.8.18
Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/

<!DOCTYPE html>
<!--STATUS OK--><html> <head> 后面太长，省略了……

//第二个post的响应
HTTP/1.1 302 Found
Connection: Keep-Alive
Content-Length: 17931
Content-Type: text/html
Date: Tue, 10 Oct 2017 09:19:47 GMT
Etag: "54d9749e-460b"
Server: bfe/1.0.8.18                                   // 这一部分是百度自己加的
<html>
<head>
<meta http-equiv="content-type" content="text/html;charset=utf-8"> //后面太长，省略了……

同样是四部分:
1 协议/版本号 状态码(1xx-5xx) 状态解释
2 Key1: value1
2 Key2: value2
2 Content-Length: 17931
2 Content-Type: text/html
3
4 要下载的内容
```
![](/img/2021-04-15-13-32-11.png)
- **HTTP状态码**（服务器对客户端返回的，响应报文中）
  - 1xx，信息性状态码; 2xx 成功状态码; 3xx 重定向状态
  - 4xx 客户端错误状态码（语法错误或请求无法完成）
    - 400 bad request 请求出错
    - 401 unauthorized 未授权
    - 403 forbidden 禁止
    - 404 not found 接口不存在
  - 5xx 服务器错误状态码
    - 500 内部服务器遇到一个未曾预料到的错误
    - 501 not Implemented 不支持请求的某个功能
    - 502 Bad Gateway 
  - 总结 服务器对浏览器说的话
    - 1xx 不常用，
    - 2xx 表示成功：200表示普通成功，201创建新的资源成功；
    - 3xx 表示滚吧：301表示永久搬走，302表示临时被封，过几天回来。304表示这一次的内容和上一次的内容是一样的。
    - 4xx 表示客服端你错了：404表示访问者出错了
    - 5xx 表示好吧，我错了：502、500表示服务器自己错了，

    - 状态码表
        |  2xx码  |  成功–表示请求已被成功接收、理解、接受  |
        |----|----|
        |  200  |  （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页  |
        |  201  |  已创建） 请求成功并且服务器创建了新的资源。  |
        |  202  |  已接受） 服务器已接受请求，但尚未处理。 |
        |204|表示请求成功，但响应报文不含实体的主体部分。
        |  3xx码  |  重定向 |
        |301|资源（网页等）被永久转移到其它URL|
        |302|临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。|
        |303|由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源|
        |304|未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。|
        |  4xx码  |  客户端错误–请求有语法错误或请求无法实现。 |
        |  400  |  （错误请求） 服务器不理解请求的语法。  |
        |  401  |    |
        |  403  |  （forbidden禁止） 服务器拒绝请求 |
        |  5xx码  |  服务器端错误–服务器未能实现合法的请求。 |
        |  500  |  服务器内部错误，无法完成请求。 |
        |  501  |    |
        |  502Bad Gateway   |  作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。 |
        |504|充当网关或代理的服务器，未及时从远端服务器获取请求。|


- HTTP和HTTPS的区别
  - 端口：http是80，https是443
  - HTTP传输时是明文传输，HTTPS是加密的
  - HTTPS更加安全，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议的信息明文传输安全。
  - 状态不同：HTTP的连接很简单，是无状态的。而HTTPS协议是SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全；
- HTTPS 加密（[漫画：什么是 HTTPS 协议？ - 小灰的文章 - 知乎](https://zhuanlan.zhihu.com/p/57142784)）
  - HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
  - 明文->共享密钥（加密解密都用一个）->使用一对对称密钥（公钥和私钥）
    - 公钥和私钥：明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。
    - 链接建立时 服务端先把公钥key1传给客户端，客户端用key1加密key2，之后就可以用key2通信了
  -  权威的证书颁发机构（CA）去颁发证书，机构利用自己的私钥来加密Key1，将证书给服务器端
     -  建立链接时，服务端将证书传给客户端
     -  客户端验证证书真伪，本地找到对应的机构公钥，解密出证书签名。服务端按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。
     -  然后利用这个公钥keyCA加密私钥key2 然后服务端用自己的私钥解密，得到key2，然后就可以用key2通信了

  - HTTP1.0，1.1，2.0

|  HTTP1.0  |  HTTP1.0 |
|----|----|
|   默认短连接 | 默认持久连接   |
|    |   管道机制 |
|  不能分块传输  |   分块传输数据 方法使发送方能将消息实体分割为任意大小的组块 分块传输数据 |
|    |   状态码 100 Continue |
| 每台服务器都绑定一个唯一的 IP 地址   |   一台物理服务器上可以存在多个虚拟主机并共享一个IP地址 因此多了Host 域 |

|  HTTP1.1  |  HTTP2.0 |
|----|----|
|    |   HTTP/2 会压缩头（Header |
| TTP/2 不再像 HTTP/1.1 里的纯文本形式的报文   | HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是 二进制，并且统称为帧（frame）：头信息帧和数据帧。   |
|    |  HTTP/2 的数据包不是按顺序发送的  |
|    |    |
|    |    |
- Cookie和Session [认识HTTP----Cookie和Session篇](https://zhuanlan.zhihu.com/p/27669892)
```md
Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
```
- Cookie
  - 会话cookie：保存在内存中，关闭浏览器后自动销毁
  - 持久cookie：保存在硬盘中
  - 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
  - 个性化设置（如用户自定义设置、主题等）
  - 浏览器行为跟踪（如跟踪分析用户行为等）

```js
//请求报文 不含cookie
GET /reader/ HTTP/1.1
Host: hackr.jp
*首部字段内没有Cookie的相关信息

//响应报文 服务器端生成Cookie 信息）
HTTP/1.1 200 OK
Date: Thu, 12 Jul 2012 07:12:20 GMT
Server: Apache
＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞
Content-Type: text/plain; charset=UTF-8
//请求报文 自动发送保存着的Cookie 信息
GET /image/ HTTP/1.1
Host: hackr.jp
Cookie: sid=1342077140226724
```
- Session [COOKIE和SESSION有什么区别？ - 轩辕志远的回答 - 知乎](https://www.zhihu.com/question/19786827/answer/28752144)

Session 代表着服务器和客户端一次会话的过程。当客户端关闭会话，或者 Session 超时失效时会话结束。
  - 存储在服务器端
  - 优点：安全性高，状态信息保存在服务端，同时可以跟踪用户状态
  - 缺点：分布式服务器中可能会导致同一浏览器多次HTTP请求在不同服务器，导致Session方法保持会话保持了。
    - 解决办法：采用中间件 Radis
  - HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用Cookie 来管理Session，以弥补HTTP 协议中不存在的状态管理功能。

- Cookie和Session的区别
  |    |  cookie  |Session|
  |----|----|----|
  |  存储位置  |  本地（内存或磁盘）  |服务器|
  |  存储容量  |  单个4k，一个站点不超过20个  |ession并没有上限（由服务器决定）|
  |  存取方式 |  Cookie中只能保管ASCll字符串，需要通过编码的方式存取Unicode字符或者二进制数据  |任意数据类型|
  |  安全性  |  Cookie 存储在客户端，比较容易遭到不法获取 |服务器|
  |有效期|按开发设置Cookie 可设置为长时间保持|会话结束，客户端关闭或者 Session 超时都会失效|


  #### DNS
  - 是一个由分层DNS服务器实现的分布式**数据库**
  - 使主机能够查询分布式数据库的应用层协议
- 为什么使用域名和IP地址
  - 1. 方便记忆
  - 2. 域名长度不固定，同时只使用域名不使用IP会给路由器负担
- DNS结构：根域名服务器，顶级域名服务器com，权限域名服务器，本地域名服务器
- 查询方式：递归查询和迭代查询
  - 迭代查询：只是指路
  - 递归查询：代为查询
- DNS为啥使用UDP（正确答案：DNS既使用TCP又使用UDP
- 进行区域传送时（主域名服务器向辅助域名服务器传送变化的那部分数据时）使用TCP。因为数据同步传送的数据量比一个请求和应答的数据量要多，同时保证了正确性
- 当客户端向dns服务器查询域名时使用UDP，因为一般返回的内容不会超过udp的报文大小



### 传输层

#### TCP

TCP的连接与断开
- TCP连接（3次握手）
  - 1. 客户端请求连接 SYN=1，seq=x
  - 2. 服务器收到，SYN=1，ACK=1， seq=y， ack=x+1 (这时候服务器知道自己能收到，客户端能发送，但是不确定服务端能不能收到)
  - 3. 客户端收到，ACK=1，seq=x+1， ack=y+1 （客户端知道自己能收到，能发送，也知道服务端能接收，能发送）
- TCP断开（四次挥手）
  - 1. 客户端申请断开 FIN=1，seq=u
  - 2. 服务端收到，ACK=1，seq=v，ack=u+1（此时服务端只是想说自己收到了，但是并没有返回FIN结束连接，可能是数据什么还没发完）
  - 3. 直到数据传完之后，服务器再发送一个FIN=1，ACK=1，seq=w，ack=u+1（被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。）
  - 4. 客户端确认收到关闭信息ACK=1，seq=u+1，ack=w+1。如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。
- TCP socket交互流程
  - 服务端
    - 
  - 客户端
- TCP报文
- TCP UDP主要特点
  - TCP 面向连接；UDP无连接
  - 端到端 
  - 可靠传输 不可靠传输
  - 全双工通信
  - 面向字节流 UDP面向
- TCP 如何实现可靠传输
  - 面向连接：三次握手，四次挥手
  - 使用序列号和确认应答机制：对每个报文段进行标号保证到达对端数据有序，同时使用确认保证对方能够收到。seq，ack
  - 超时重传机制：若迟迟未收到对方确认应答，则认为发送失败，重新发送
  - 流量控制
    - TCP 连接的每一方都有固定大小的缓冲空间。TCP 的`接收端`只允许另一端发送接收端缓冲区所能接纳的数据。 这将防止`较快主机致使较慢主机的缓冲区溢出`。TCP 使用的流量控制协议是可变大小的滑动窗口协议。滑动窗口协议（连续ARQ协议）
    - 当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。
    - 为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。
  - 拥塞控制
    - 慢启动，定义拥塞窗口，最开始为1，收到确认应答时，拥塞窗口乘2

    - 拥塞避免：设置慢启动阀值。如果达到阀值后每次窗口数加法增长，避免拥塞
  
    - 快重传：要求对方接收到数据后立刻发送应答报文，而不是捎带发送，若发送方收到三个充分的ack，则直接进行重传
  
    - 快恢复：当发送端收到三个重复的应答后，将拥塞窗口设置为当前的一半，然后用拥塞避免算法重新启动。
![](/img/2021-04-17-09-07-21.png)
    - 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。
    - 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。
    [TCP流量控制、拥塞控制 - 似水流年的文章 - 知乎](https://zhuanlan.zhihu.com/p/37379780)
![](/img/2021-04-17-09-43-51.png)

|  TCP  |  UDP  |
|----|----|
|  面向连接  |  无连接  |
|  可靠传输  |  尽最大努力交付  |
| 开销大 |  UDP首部开销小  |
|  慢  TCP 必须创建连接 | 快  |
|   TCP 数据报的报头大小最少是 20 字节 |  UDP 数据报的报头固定是 8 个字节  |
|  TCP 有流量控制和拥塞控制  |  UDP没有流量控制和拥塞控制  |
|TCP 只能单播|UDP 可以广播和组播|

