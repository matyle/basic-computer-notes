# 传输层
## 总图

<center>
    <img style="border-radius: 1.125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src=img/2021-07-20-17-07-02.png
width=450px>
</center>


## UDP
- 无连接服务
- 缺乏可靠性，需要在应用层添加确认，本端超时与重传
- udp数据报有长度字段


## TCP
- 提供连接，先给某个给定服务器建立一个连接（三次握手）
- 提供可靠性：确认，超时重传
- 为了知道等待一个确认需要多长时间，可以动态估算客户和服务器之间的RTT（往返时间）
- 为每个字节关联的一个序列号的发送数据进行排序

- 流量控制（通知窗口）
- 拥塞控制
- 全双工连接（一个给定的连接上应用可以在任何时刻在进出两个方向既发送数据又接收数据。
  - 给了一个FIN只是说明不再发送数据，但是不代表不接收数据，另一端可能还没有发送完毕）





## SCTP
- SCTP为客户端和服务器之间提供关联，并提供可靠性，排序，流量控制，和全双工


## TCP连接的建立与终止

### 三次握手

1. 必须准备好接受外来连接，调用socket，bind，listen 被动打开
2. 客户通过调用connect 发起主动打开。这导致客户端发送一个SYN（同步分节),它告诉服务器将在待建立连接中发送的数据的初始序列号。**一般来说SYN不携带数。IP数据报只包含一个IP首部，TCP首部以及可能TCP选项**
3. 服务器必须确认ACK客户端的SYN，同时自己也必须发送一个SYN分节，它含有初始序列号。同时在单个分节中发送确认号ACK
4. 客户端必须返回确认号，确认SYN

- 这种交换需要至少3个分组，因此叫三次握手
<center>
    <img style="border-radius: 1.125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src=img/2021-07-20-17-24-48.png
width=450px>
</center>


### TCP选项




### TCP链接终止
- 连接需要3个分节，终止一个连接则需要4个分节
1. 某个应用进程首先调用close,**称该段执行主动关闭**。
2. **接收到FIN对端执行被动关闭**，FIN由TCP确认，接收作为一个EOF，传递给接收端应用进程（放在已排队等待该应用进程接收的任何其他数据之后
3. 一段时间后，接收到eof的应用程序进程调用close关闭套接字，发送FIN
4. 接收这个FIN的原发送端确认这个FIN

- 每个方向都需要一个FIN和ACK 因此通常需要四个分节
- 步骤2-3之间叫做半关闭

<center>
    <img style="border-radius: 1.125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src=img/2021-07-20-17-37-25.png
width=450px>
</center>


## TIME_WAIT状态
- 分组在网络中迷途通常是路由异常的结果。在一个分节迷途期间，发送端tcp重传了这个分节并到达接收端。但是不久之后迷途的分节也到达了目的地
- TIME_WAIT状态存在的理由
  - 可靠的实现TCP全双工连接的终止
  - 允许老的重复分节segment在网络中消逝






## 端口号




## tcp端口号与并发服务器

- 并发服务器有多个子进程，但是使用了相同的端口，tcp如何区分？
  - 使用服务器的套接字对`{*:21,*:*}` 来区别。*：21表示服务器的地址和端口，而后面的`*：*`表示客户端的地址和端口（因为客户端每个端口必须是唯一的）
<center>
    <img style="border-radius: 1.125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src=img/2021-07-21-08-55-03.png
width=450px>
</center>


## 缓冲区大小 限制


### TCP输出

- 每一个tcp套接字都有一个发送缓冲区，使用SO_SNDBUF更改缓冲区大小。
- 进行write系统调用时，是将应用进程缓冲区的数据写入到tcp写套接字的发送缓冲区。
  - 如果缓冲区容不下该进程的所有数据（或者进程缓冲区大于套接字的发送缓冲区，或者套接字发送缓冲区已经有其他数据）这时应用进程会睡眠（假设套接字阻塞），内核不会从write系统调用返回，直到进程缓冲区的数据全部被复制到套接字发送缓冲区
  - **因此，write的返回 只能说明数据已经全部写到了发送缓冲区，并不代表对端的tcp或者进程收到了数据**
  - 直到收到对端的ACK，才丢弃发送缓冲区中已确认的数据
  
    <center>
        <img style="border-radius: 1.125em;
        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
        src=img/2021-07-21-09-03-23.png
    width=450px>
    </center>



### UDP输出

- udp并不存在发送缓冲区，因为它本身是不可靠的，不需要使用发送缓冲区存储已经发送的数据
- 但是它有缓冲区大小，仅仅代表能写到套接字的udp数据报大小的上限


- 来自用户的数据报安装8字节的首部，成为udp数据报，然后传递给IP数据报

