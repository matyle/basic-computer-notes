## 什么是闭包



闭包是由==函数及其相关引用环境组合==而成的实体，即：



> 闭包=函数+引用环境



一般的函数都有函数名，但是匿名函数就没有。匿名函数不能独立存在，但可以直接调用或者赋值于某个变量。匿名函数也被称为闭包，一个闭包继承了函数声明时的作用域。在Golang中，所有的匿名函数都是闭包。

有个不太恰当的例子，可以把==闭包看成是一个类==，一个闭包函数调用就是实例化一个类。==闭包在运行时可以有多个实例==，它会将同一个作用域里的变量和常量捕获下来，无论闭包在什么地方被调用（实例化）时，都可以使用这些变量和常量。而且，闭包捕获的变量和常量是引用传递，不是值传递。





### 小栗子

```go
package main
import "fmt"
func main() {
	//fmt.Printf("%d\n", Accumulator()(1))
	//fmt.Printf("%d\n", Accumulator()(2))
	/*
		(0xc000014088,1)---1
		(0xc00009c000,2)---2
	*/

	a := Accumulator() //a是一个实例
	b := Accumulator() //b是一个实例

	fmt.Printf("%d\n", a(1))
	fmt.Printf("%d\n", a(10))
	fmt.Printf("%d\n", a(100))

	//b实例
	fmt.Printf("%d\n", b(1))
	fmt.Printf("%d\n", b(10))
	fmt.Printf("%d\n", b(100))
}

//匿名函数，返回一个函数
func Accumulator() func(int) int {
	//同一个实例地址相同
	var x int
	return func(delta int) int {
		x += delta
		fmt.Printf("(%v,%v)---", &x, x)
		return x
	}
```



输出：可以发现，a中的x地址一直是相同的，b的地址是另外一个！

```go
	/* 输出
		(0xc000096000,1)---1
		(0xc000096000,11)---11
		(0xc000096000,111)---111
		(0xc000096008,1)---1
		(0xc000096008,11)---11
		(0xc000096008,111)---111
	*/
```

闭包引用了x变量，a,b可看作2个不同的实例，实例之间互不影响。实例内部，x变量是同一个地址，因此具有“累加效应”。



参考：[参考博客](https://qcrao.com/2019/02/12/how-to-keep-off-trap-of-defer/)