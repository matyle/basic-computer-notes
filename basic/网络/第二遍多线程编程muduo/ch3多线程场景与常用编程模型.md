# 第三章 多线程场景与常用编程模型


## 3.1 进程和线程
- 粗略的说：进程是正在运行的程序。使用fork()产生
- 独立的地址空间，在同一个进程还是不在同一个进程是系统功能划分的重点
  - 进程能够高效共享代码段，但不能共享数据。
- 线程的特点是：共享地址空间，高效共享数据

## 3.2 单线程服务器的常用编程模型
最为广泛的模型：nonblocking IO + IO复用模型，即Reactor模式
- Reactor模式：
- lighttpd，单线程服务器。Nginx与之类似，每个工作进程有一个event loop。 fdevent结构
- libevent, libev; 
- ACE

- onblocking IO + IO复用模型：基本结构是一个**事件循环**，以**事件驱动**和事件回调方式实现业务逻辑
  ```cpp
  while(!done){
      int timeout = max(1000,getNextTimeCallbac());
      int retval = ::poll(fds,nfds,timeout_ms);
      if(retval<0){
          处理错误 回调用户的error handler
      }
      else{
          处理到期的timer,回调用户的timer handler
          if(retval>0){
              处理io事件，会调用户的IO event handler
          }
      }
  }
  ```

## 多线程服务器常用的编程模型
1. 每个请求创建一个线程，使用阻塞IO操作 伸缩性不佳
2. 使用线程池，同样使用阻塞式IO
3. 使用non-blockingIO + IO mutiplexing(IO复用)，即java NIO模式
4. Leader/Follower等高级模式
- 一般使用第三种non-blockingIO + IO mutiplexing(IO复用)


### one loop per thread
- 这种模型中，每个IO线程有一个事件循环（event loop)或者叫Reactor，处理读写事件和超时事件。libev
- 优点：
  - 线程数目固定，可以启动的时候设置，不会频繁创建和销毁
  - 可以方便在线程间调配
  - IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发

- 需要哪个线程干活就把timer或者IOchannel（如tcp连接）注册到哪个线程的loop里即可。
  - 实时性要求的connection可以单独用一个线程
  - 数据量大的connection可以独占一个线程，并把啊数据处理任务分摊到几个计算线程中
  - 其他次要的辅助性连接可以共享一个线程。
- 对于non-trivial服务器端程序，非阻塞+IO复用 每个connection/acceptor都会注册到某个event loop上
- 多线程中需要考虑线程安全
## 线程池

- 对于没有IO而只有计算任务的线程，使用event loop有点浪费。可以使用blocking queue实现的任务队列
- 使用队列来管理线程，注意加锁解锁
  ```cpp
  
  ```


## 多线程服务器使用场合
- 当线程很廉价时，一台机器可以创建远高于cpu数目时，，这时一个线程只处理一个或者半个TCP连接，通常使用阻塞IO（等待） Python gevent，Go goroutine，Erlang actor
- 当线程很贵时，只能创建CPU数目相当的线程时， 一个线程要处理多个TCP连接上的IO，这时使用非阻塞IO+IO复用。例如libevent，muduo
- 线程是属于一个进程（模式2）还是属于多个进程（模式3）
- 本节**进程是fork（2**）生成的，线程时**pthread_create()的产物**（宝贵原生线程），而且是NPTL的，每个**线程由clone(2)**产生，对应一个**内核的task_struct**。
- 可用模式（model）：
  1. 运行一个单线程的进程
  2. 运行一个多线程的进程
  3. 运行多个单线程的进程
  4. 运行多个多线程的进程
   - 模式1 不可伸缩
   - 模式3是主流模式
     - 3a：简单把模式1运行多份
     - 3b:主进程+work进程，

- 本文讨论模式2和模式3b的优劣，什么时候该用多线程
- 单线程和多线程都能做到
- 无论是IO bound或者是cpu bound，多线程在性能上没有绝对的优势


### 必须使用单进程情况

1. 程序可能会fork(2)，只有单线程程序才能fork,多线程调用fork会有很多麻烦，调用fork之后会有两种行为
   1. 立刻执行exec()成为一个新的程序
   2. 不调用exec()，继续运行当前程序，通过共享父进程的文件描述符与父进程通信，协同完成任务，要么接过父进程传来的文件描述符独立完成任务。
2. 限制程序的cpu占用率，单线程程序能够限制CPU占用率，假设运行在8核电脑上的一个单线程程序有了bug或者overload占满一个core，利用率最坏情况也才12.5%

- 单线程的优缺点
  - 简单，基于IO复用的事件循环
  - 缺点：是非抢占的，如果优先级高的事件a需要1ms，事件b 10ms 但是b先于a运行，那么整个就要11s，多线程可以解决这个问题
  - IO bound或者是cpu bound 也就是cpu跑满
  - 对于静态web，FTP服务器主要瓶颈在磁盘IO和网络IO方面，这时候一个单线程程序模式1就能够撑满IO了
  - CPU跑满的情况：3a比较合适，也不是多线程优势

### 适用多线程程序的场景

- 作者认为多线程适用场景：提高响应速度，让IO和计算相互重叠，降低延迟。多线程不能提高绝对性能，但是能够提高平均性能
- 一个程序能作为多线程，大致要满足
  - 有多个cpu可以用
  - **线程间有共享数据**，即内存的全局状态，如果没有共享数据直接用模式3b
  - **共享数据可以修改**，而不是静态的常量表。如果不能修改，直接用模式3 共享内存就可以了
  - **提供非均质的服务**，事件响应的有优先级差异。利用专门的线程处理优先级高的事件，防止优先级反转
  - 延迟和吞吐量同样重要。不是逻辑简单的IO bound或者是CPU bound，要有一定计算量
  - **利用异步操作**。例如logging，不论是往磁盘写log file还是往log sever发送消息都不应该阻塞critical path
  - 伸缩性好，能scale up。能够享受增加cpu带来的好处
  - 具有可预测的性能，线程数目一般不随负载变化
  - **多线程能有效划分责任和功能**。让每个线程逻辑简单，任务单一。而不是把所有任务都塞到event loop里面
- 例子 计算集群管理的master程序，聊天服务器程序

- 多线程服务器中线程分为3类
  - IO线程，主循环是IO复用，阻塞等在select/poll/epoll_wait系统调用，也处理定时事件，消息的编码与解码
  - 计算线程，主循环是blocking queue中，阻塞等在条件变量上。这类线程一般位于线程池中，一般不涉及IO，避免任何阻塞操作
  - 第三方库所用的线程，比如logging，数据库连接
- 服务器程序不会频繁启动终止线程，create_thread只会在程序启动时调用

- 线程不能减少工作量