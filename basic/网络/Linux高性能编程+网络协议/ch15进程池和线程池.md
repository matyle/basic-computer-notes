# 15 进程池和线程池

- 动态创建进程或着线程比较耗费时间，导致较慢的用户相应
- 动态创建的子进程或子线程通常只为一个客户服务，导致产生大量的细微进程或线程，他们之间的切换消耗大量的cpu时间
- 动态创建的子进程是父进程的完整映像，文件描述符和堆 子进程都会复制，从而使系统资源急剧下降，影响服务器性能

## 进程池和线程池概述

- 进程池和线程池相似，没有特殊说明，进程池完全适用于线程池
- 进程池是由服务器预先创建的一组子线程，这些子进程数目在3-10个之间
- 线程池中的**线程数量应该和cpu数目差不多**
- 进程池中运行着相同的代码，并具有相同的属性，如优先级，PGID等。因为线程池是在服务器启动之初就创建好了，因此**子进程相对“干净”**，即他们没有不必要的文件描述符，也不会错误使用大块堆内存
- 当有新的任务到来时，主进程通过某种方式选择进程池中的一个子进程为之服务
  - 1. 最简单，最常用的算法是`随机算法和Round Robin轮流选取`
  - 2. 主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列中。当任务到来时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程将获得新任务的“接管权”
  - 3. 选择好子进程后，需要以某种通知机制告诉子进程有任务需要处理，并传递必要数据。例如**管道通信**，预先建立一条管道，，然后通过这个管道实现所有进程间的通信（需要一套协议规范使用）
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-05-15-53-41.png
  width=490px>
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;"></div>
  </center>
  

## 处理多客户
监听socket和连接socket是否都由主进程统一管理？

- 半异步/半反应堆：由主进程统一管理两种socket的
- 半异步/半同步模式以及领导者/追随者模式：主进程管理所有监听的socket，各个子进程分别管理属于自己连接的socket
  - 前一种情况：主进程传递socket，（对于线程池，父线程将socket传递给子线程比较简单，共享的）对于进程池要利用`socketpair`管道传递文件描述符
  - 后一种情况：子进程自己调用accept来接受新的连接，父进程只需要通知一声就可以了 （signal）
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-05-16-08-41.png
  width=490px>
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;"></div>
  </center>

## 半同步/半异步进程池实现

## 半同步/半反应堆线程池

- 通用性更高，解除了主线程和工作线程的偶尔关系 worker



## http简单实现
