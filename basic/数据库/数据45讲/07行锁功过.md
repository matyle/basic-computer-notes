- 行锁就是针对数据表中行记录的锁。比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

<center>
    <img style="border-radius: 1.125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src= img/2021-07-17-15-56-55.png
width=450px>

</center>

- 事务 B 的 update 语句执行时会是什么现象呢？
  - 被阻塞了。直到事务 A 执行 commit 之后，事务 B 才能继续执行。
  - 是按行来阻塞的！！！都是在 commit 的时候才释放的。

- 在 InnoDB 事务中，**行锁是在需要的时候才加上的**，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。



### 死锁和死锁检测

- 当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-07-17-16-22-55.png
  width=450px>
  </center>

  - 相互等待资源发生死锁，mysql8.0下 会直接检测到死锁，然后关闭事务
  ```sql
  mysql> update t set k=k+1 where id = 100;
    ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
  ```

- 死锁后两种策略
  - **一种策略是，直接进入等待，直到超时**。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，、
  - **另一种策略是，发起死锁检测（默认）**，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

- 超时时间短容易误伤
- 死锁检测，需要额外的负担。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。这是一个时间复杂度是 O(n^2) 的操作
- 假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。


- 通过数据分段的思想，减小死锁冲突的概率
  - 你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。
  - 热点行更新的解决策略: 
  - 降低并发度 
  - 1. 拆行，一行拆多行 
  - 2. Server 层限流，即同一时间进入更新的线程数 
  - 3. 关闭死锁监测（关闭的弊端是可能超时较多）

