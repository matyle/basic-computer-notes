# 08事务到底是隔离的还是不隔离的
- 这篇文章还不是很理解，笔记还不全。
- 如果你想要马上启动一个事务，可以使用 `start transaction with consistent snapshot` 这个命令。
  - **第一种启动方式使用begin，一致性视图是在执行第一个快照读语句时创建的** 这时会创建事务id，但是没有创建一致性视图
  - 第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。


<center>
    <img style="border-radius: 1.125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src=img/2021-07-20-16-48-30.png
width=450px>

</center>

- **默认 autocommit=1。即除非显示声明一个事务的开始，否则每一个查询都会被当做独立的事务被处理。因此一个语句是马上提交的。** 例如c
  - 事务B之所以查到的是3，是因为事务B的更新是在事务C更新的基础之上修改的。在修改的时候，需要先读然后再修改，事务B读取的时候，确实不会读取到事务C的更新后的内容。但是事务B进行更新的时候，会执行当前读，所谓当前读就是读取当前数据库中最新的数据内容，如果不执行当前读，而直接基于一致性读的前提下，直接执行更新操作，将会把事务C的更新给丢失掉。所以事务B更新的时候，是在已经提交的事务C的基础上更新数据。所以事务B就出现一个现象：执行更新前查询的值为(1,1)，执行完更新之后，会变成(1,3)，而不是(1,2)。 MySQL中读取数据的时候总是一致性读：事务开始前会创建一个一致性视图，在事务执行过程中，所有其他未提交或者已经提交的事务，对当前已经开启的事务不可见。 但是在更新数据的时候，会执行当前读：意思是在更新之前会去数据库中获取最新的已经提交的事务数据内容，然后基于已经提交的事务的基础上更新自己的内容。


- select是读快照，update是当前读


### 视图
- 在 MySQL 里，有两个“视图”的概念：
  - 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。
  - 另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。




- Begin/start transaction与start transaction with consistent snapshot的区别 也说明一个事务并不是都有readview，比如一个仅有update的事务

- 获取事务id 和 创建一致性视图 是两个操作:
  - 获取事务id: 是在begin事务的时候.
  - 创建一致性视图: 是在事务的第一条语句执行的时候.

### “快照”在 MVCC 里是怎么工作的？
- MVCC 多版本并发控制，看似在拷贝，其实不是利用的拷贝
  - 数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。通过版本号将一行数据连接成一个版本链，然后各个事务通过当前的事务ID和数据行的版本链进行对比，拿到它该读的版本数据
  - undo log记录所有事务，在事务内更改过的历史版本数据 {数据ID,事务ID,数据} 更改时，是把旧数据的记录到undo log还是把新数据记录到undo log


- **可重复读的定义**：一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。

  - 一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。
  - 如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。


- 实现： InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。**“活跃”指的就是，启动了但还没提交**。
  - 数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。
  - 这个视图数组和高水位，就组成了当前事务的**一致性视图（read-view）**
  - 注意：生成一致性视图时是(原子操作，这中间不可能存在其他事务提交)
  - 假设有ABC三个事务，100 101 102，这时还没生成一致性视图？
    - a: begin 获取事务id 5;
    - b：第一条语句生成事务5的数组;
    a+b操作并不是原子的，而b操作自身是原子的，而由于a+b操作并不原子导致b操作生成的数组元素在当前事务5和高水位之间不连续，小于5的也可能不连续，也就是图片中黄色区域并不连续，不连续的元素中存在 在a 和b 操作之间，提交的事务（x集合），x这部分就是3b的情况。
    所以图片黄色部分叫 未提交事务集合 是有问题的。


- select是一致读，update是当前读（如何实现？）
- 






### 问题

- 现在，我要把所有“字段 c 和 id 值相等的行”的 c 值清零，但是却发现了一个“诡异”的、改不掉的情况。请你构造出这种情况，并说明其原理。
- t1: session1: begin; select * from t; t2: session2: update t set k=k+1; t3: session1: update t set k=0 where id=k; select * from t; 
- 理由：更新是当前读；当前读，最新版本where没有匹配的行


- （1）事务A：begin;select * from t; 事务B：update t set c=0 where id=c；事务B隐式提交 （2）此时事务A执行update t set c=0 where id=c；这里update是当前读，读取的是最新版本的记录，那么id=c的记录已经在B事务中被修改了，此时update就失败了 （3）事务A继续执行查询select * from t；查询是一致性读，读的是begin后面执行的那句查询创建的视图
```sql

mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, c) values(1,1),(2,2),(3,3),(4,4);

update t set c=0 where id=c;

```

