## 索引是什么？
- 某一个 SQL 查询比较慢，分析完原因之后，你可能就会说“给某个字段加个索引吧”之类的解决方案。(优化)
- 索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。
### 三种索引：哈希表，有序数组和搜索树
- **哈希表**：实际上是一种数组下标的映射，以减少数组的开销，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。可能会出现冲突：处理的一种方法为：拉出一个链表
<center>
    <img style="border-radius: 1.125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src=img/2021-07-16-15-39-25.png
width=450px>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">哈希表示意图</div>
</center>

  - 解决冲突的办法很简单，但是因为不是有序的如果一条链表太长还是会很慢，同时对哈希索引做范围查找查询也会很慢
  - 如果要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。
  - **哈希表这种结构适用于只有等值查询的场景**，比如 Memcached 及其他一些 NoSQL 引擎。
 

- 有序数组在等值查询和范围查询场景中的性能就都非常优秀。
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-07-16-15-45-24.png
  width=450px>
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;">有序数组</div>
  </center>

  - 查找的时候因为有序，可以使用二分法。时间复杂度O(log(n));
  - 查找范围也快，利用二分法先找到ID_card_X,然后向右遍历ID_card_Y
  - 插入删除效率低，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。
  
  - **有序数组索引只适用于静态存储引擎**，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。

- 二叉搜索树
  - 父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。
  - 为了维持O(log(N))的复杂度，需要维护二叉树的平衡。需要旋转操作
- 二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。**其原因是，索引不止存在内存中，还要写到磁盘上。** 
  - 因为树太高，导致读磁盘的次数也增加了。树的高度，就是要查询的数据块的数量，因为需要从根节点，遍历到叶子节点。
  - 为了减少读取磁盘次数，我们需要减少树高，使用N叉树。


- 例子：
  - 以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。


## InnoDB的索引模型
- 表是根据主键顺序以索引的形式存放的，这种存储方式的表称为**索引组织表。**

```sql

mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;

insert into t(id,k,name) 
values (100,1,"liming"),(200,2,"xiaohong");
```
<center>
    <img style="border-radius: 1.125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src=img/2021-07-16-16-01-37.png
width=450px>
</center>

- 根据叶子节点的内容，索引类型分为主键索引和非主键索引。
- ID为主键，主键索引的叶子节点存的是整行数据，主键索引也被称为**聚簇索引**（clustered index）。
- 非主键索引的**叶子节点内容是主键的值。**在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。

- 这两个有啥区别呢？
  - 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
  - 如果语句是 select * from T where k=5，即普通索引查询方式，**则需要先搜索 k 索引树，得到 ID 的值为 500**，**再到 ID 索引树搜索一次。这个过程称为回表**。搜索树两次，第二次查询主键索引称为回表
  - 也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。
- 插入和删除
  - 插入的情况有多种，比如插入700，直接在R5后面加一个就行（页未满情况下），如果插入400，就要挪动数据
  - 如果页满，则需要页分裂
### 索引维护

- **插入有可能导致分页，删除有可能导致页合并**，导致的问题是磁盘利用率低，有空隙，这里一般分页的大小等于磁盘页的大小一致，这样分页逻辑性比较好。删除（delete），**其实只是标记被删除**，并不释放磁盘空间，以备复用改磁盘空间。（线上有很多次磁盘快满了，就是释放不掉的问题）
- 分页为什么会导致利用率下降？
  - 因为插入是递增 顺序的比如12345678910分裂为 1234 5678910两个页，前面那个页是不能再插入数据的。
- 当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。



- **为什么从性能和存储空间方面考量，自增主键往往是更合理的选择。看下文：**
- 插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。
- 一般使用自增主键，保证递增插入，且都是追加操作，不会触发叶子节点分裂
- `NOT NULL PRIMARY KEY AUTO_INCREMENT。`
  ```sql

    create table a(
    id int not null primary key AUTO_INCREMENT, 
    k int not null, 
    name varchar(16),
    index (k))engine=InnoDB;

    insert into a(k,name) 
    values (1334342,"liming"),(232423,"xiaohong");
    ```

- 除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？
    - 如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。  
- **显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**


- 当然有些场景，必须要业务字段做主键
    - 只有一个索引；
    - 该索引必须是唯一索引。


    ```sql
    
    alter table T drop index k;
    alter table T add index(k);


    alter table T drop primary key;
    alter table T add primary key(id);
    ```

    - **为什么要重建索引**？
        - 我们文章里面有提到，索引可能因为**删除，或者页分裂等原因，导致数据页有空洞**，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。

    - 上期的问题是，通过两个 alter 语句重建索引 k，以及通过两个 alter 语句重建主键索引是否合理。’


    - 重建索引 k 的做法是合理的，可以达到省空间的目的。**但是，重建主键的过程不合理。不论是删除主键还是创建主键**，都会将整个表重建。
    - 所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。




