第二部分 ：静态链接
# 编译和链接
深入了解编译链接运行机制，能够更加容易解决问题和突破性能瓶颈


## 被隐藏了的过程
build的时候的四个步骤：
- 预处理 使用预编译器cpp
- 编译 cc1 c++中是cc1plus
- 汇编 as
- 链接 ld（链接器）
<center>
    <img style="border-radius: 1.125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src=img/2021-06-19-08-42-49.png
width=390px>
</center>


### 预处理
- 源代码文件hello.c和相关头文件被预编译器编译成一个.i文件。
- 如果是c++程序，hello.cpp和头文件被预编译器编译为.ii文件
- `gcc -E hello.c -o hello.i或者 cpp hello.c>hello.i`

- **预编译过程**主要处理以#开头的预编译指令，如#include，#define等
  - 将所有的#define删除，展开宏定义
  - 处理所有条件预编译指令，#if,#ifdef,#ifndef,#elif,#else,#endif
  - 处理#inclue预编译指令，递归将包含的文件到该预编译指令的位置
  - 删除所有注释// 和 /**/
  - 添加行号和文件名标识。如#2"hello.c"2，便于编译时调试器产生调试用的行号信息，已经警告或者报错使用的行号
  - 保留所有#pragma指令，因为编译器必须使用
- .i文件不含任何宏定义，宏已经被展开，且包含的文件已经插入到.i文件。因此我们无法判断宏定义和头文件正确包含时，可以查看.i文件


### 编译
c程序调用cc1`gcc -S hello.i -o hello.s`
- 进行一系列词法（扫描），语法，语义分析，以及优化后产生相应的汇编代码文件。
- 

### 汇编

调用汇编器as进行 `as hello.s -o hello.o 或者 gcc -c hello.s -o hello`
- 汇编器将汇编代码啊转变成机器可以执行的指令，一个汇编语句对应一个机器指令

### 链接（本书重点）
为什么汇编完不直接输出可执行文件？

- 静态链接
`ld -static ctr1.o crti.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend.o crtn.o`
- 将一大堆文件链接起来才能得到最终的可执行文件
- 为什么虚拟地址可以简化分配？

## 编译器lcc做了什么

- 编译器将高级语言翻译为机器语言
- 编译过程可分为6步
  1. 扫描 词法分析
  2. 语法分析
  3. 语义分析
  4. 源代码优化
  5. 代码生成
  6. 目标代码优化
   <center>
       <img style="border-radius: 1.125em;
       box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
       src=img/2021-06-19-09-08-04.png
   width=390px>
   </center>
```c
array[index] = (index + 4) * (2 + 6);
//ComplierExpress.c
```
### 词法分析

- 首先，源代码程序被输入到扫描器（Scanner），运用**有限状态机**算法，将字符序列分割为一系列记号Token
- 记号分类：关键字，标识符，字面量，特殊符号。标识符放到符号表，数字等字面量放到文字表
<center>
  <img style="border-radius: 1.125em;
  box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
  src=img/2021-07-21-15-51-58.png
width=450px>
</center>


### 语法分析
- 语法分析器对扫描器产生的记号进行语法分析，从而产生语法树(Syntax Tree)。
- 使用上下文无关语法啊。语法树是以表达式为节点的树
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-19-09-17-36.png
  width=390px>
  </center>
  
- 赋值表达式左边是数组表达式，右边是乘法表达式。数组表达式又有两个符号表达式组成。优先级和含义也被确定，例如*比+优先级高，
- 语法分析工具叫yacc。编译器编译器

### 语义分析器
- 上面是检查语法，例如符号匹配。
- 语义分析器，所能分析的是静态语义。在编译期间可以确定的语义。
- 动态语义只能在运行期间才能确定（例如/0）
- **静态语义包括声明和类型的匹配**
- 语义分析在语法树插入相应的节点，表明类型，类型的转换
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-19-09-38-07.png
  width=390px>
  </center>




### 中间语言生成
- 源码级优化器：例如一些在编译期间就可以确定的值
- 往往将整个语法树转换成中间代码，语法树的顺序表示：例如三地址码和P代码
- 三地址码：`x = y op z;`,
  ```c
  array[index] = (index + 4) * (2 + 6);
  
  //中间代码 三地址码
  t1 = 2 + 6;
  t2 = index + 4;
  //t2可以不用了
  t2 = t2 * 8
  array[index] = t2
  ```
- 编译器前端负责产生机器无关代码的中间代码。后端将中间代码转化为目标机器代码
### 目标代码生成与优化
- 代码生成器和目标代码优化器
- `32(,%edx,8)` 等价于`M(32+R[%edx]*8` ,后面*号是一个伸缩因子，必须是1，2，4，8
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-19-10-04-12.png
  width=490px>
  </center>
  
  ```c
  movl index, %ecx;
  ```
-  经过这么多步骤成为目标代码，**index和array的地址还没有确定**，index和地址应该从哪里来？
-  目标代码中有变量定义在其他模块怎么办？因此需要链接呀

## 2.3 链接器年龄比编译器长
- 将所有源代码都写到一个源文件中，导致后来一个源文件有几百万行，导致人们没有能力维护，因此找了新的方法
- 程序写好了可能会改变，向其中某指令前插入指令之后，前面的跳转指令中的目的指令的地址会发生变化，因此需要修正，修正过程叫做重定位
- 链接过程包括：**地址和空间分配（得益于虚拟内存，才能够简化链接，使得逻辑地址能够一致），符号决议和重定位**等
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-19-10-37-47.png
  width=390px>
  </center>
  
- 模块的组装就是链接
- 重定位：当编译文件A时，编译器不知道var的地址，因此mov指令中地址为0，当A和B链接的时候将其修正。地址修正的过程叫做**重定位**，修正的地方叫做**重定位入口**
- 符号间的引用


## 静态链接
- 各模块独立编译之后，然后组装起来就是链接。
- 链接过程包括了：**地址和空间分配，符号决议和重定位等**
- 例如main.c中使用了func.c中的foo，而main在编译时无需知道地址，暂时将其目标地址搁置。等到链接时将这些指令的目标地址修正