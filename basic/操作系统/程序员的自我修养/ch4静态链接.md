# 第四章 静态链接


## 空间与地址分配

### 策略1：按序叠加
- 简单空间分配策略：直接合并的方法，将所有目标文件的段依次合并，这样虽然简单，但是目标文件多了之后，会有很多零散的段。非常浪费空间。
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-24-09-16-19.png
  width=390px>
  </center>

- **段的装载地址和空间对齐单位是1页，4096字节，如果只有一字节的段也会占用1页 4096字节** ，造成大量内部碎片

### 策略2 ：相似段合并
- .text合并输出到.text，.data合并到.data，接着是.bss段等
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-24-09-18-32.png
  width=390px>
  </center>
  - .**bss段在目标文件和可执行文件不占用文件空间，但是装载时占用地址空间**，因此也需要合并。

- **什么是空间？**
  - 输出的可执行文件中的空间（磁盘）
  - 装载后的虚拟地址中的虚拟地址空间
  - 对于.text和.data都需要分配空间（实实在在的文件代码和数据）
  - .bss这样的段来说只局限于虚拟地址空间，因为在文件没有内容。
  - 一般在这里谈到的基本都是虚拟地址空间分配

- **两步链接方法**
  - **空间与地址分配**：扫描所**有目标文件 获得各个段长度，属性和位置**。将目标文件中的所有符号定义和符号引用收集起来，放到一个**全局符号表**；同时链接器能够获得所有段的长度，并将它们合并。最后计算输出文件中各个段的长度和位置，**并建立映射关系**
  - **符号解析与重定位**：根据上一步的信息（全局符号表），读取输入文件中段的数据，重定位信息，并进行符号解析和重定位，调整代码地址等。
  - 分析a.o，b.o 和ab的关系
    - `gcc -c a.c b.c` 生成a.o,b.o
    - ld a.o b.o -e main -o ab   其中-e main将 main作为入口
    - `ld a.o b.o -fno-stack-protector -e main -o ab -shared`
    - 在GFLAGS里面添加-fno-stack-protector
    - 学makefile
  ```c
    swap(*int, *int);
    extern int shared;
    int main(){
        int a = 100;
        swap(&a,&shared);
    }
    //b.c
      int  shared = 1;
      void swap(int *a,int *b){
              *a ^= *b ^= *a ^= *b;
      }
  
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-24-09-58-18.png
  width=490px>
  </center>



- VMA表示虚拟内存区域：Linux实际都是从08048000开始，然后开始偏移


### 符号地址的确定
- 在第一步扫描的时候其实**每个段的虚拟地址**已经确定了 例如.text在0x08048094开始，.data从0x08049108开始
- 链接器给每一个符号加上一个偏移量，能够调整到正确的位置，例如main函数是函数的入口所以相对于.text偏移为0，相应的根据swap相对于.text的偏移
- shared是0x08049108，也就是.data的起始位置


## 符号解析与重定位

### 重定位
- 在分配空间之前（ld）之前，程序中函数都是从0开始，这时候并未确定自己在虚拟地址空间中的位置，要等函数分配完成之后才会确定地址。


### 重定位表 == 重定位段

- 例如.text需要重定位的话，它的重定位表（段）.rel.text 。如果是data,则为.rel.data
- 通过 `objdump -r a.o`可以查看重定位表
- 高24位表示在符号表中的下标



  ```c

     Offset(偏移)    Info    Type            Sym.Value  Sym. Name
    0000001b    00000a01 R_386_32          00000000   i//全局变量 main中调用偏移1b 是代码段 操作的偏移！！！看前面指令，而不是i本身存储的data段地址！！！ info中高24位为 01 0a 00 
    00000024    00000802 R_386_PC32        00000000   foo

    00000000 <foo>:
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 55 08                mov    0x8(%ebp),%edx
   6:   8b 45 0c                mov    0xc(%ebp),%eax
   9:   01 d0                   add    %edx,%eax
   b:   5d                      pop    %ebp
   c:   c3                      ret    
   0000000d <main>:
    d:   55                      push   %ebp
    e:   89 e5                   mov    %esp,%ebp
    10:   83 ec 10                sub    $0x10,%esp
    13:   c7 45 fc 01 00 00 00    movl   $0x1,-0x4(%ebp)
    1a:   a1 00 00 00 00          mov    0x0,%eax//从1b开始就是i 所以i的A是00000000，00000a是S实际地址
    1f:   ff 75 fc                pushl  -0x4(%ebp)
    22:   50                      push   %eax
    23:   e8 fc ff ff ff          call   24 <main+0x17>
    28:   83 c4 08                add    $0x8,%esp
    2b:   b8 00 00 00 00          mov    $0x0,%eax
    30:   c9                      leave  
    31:   c3                      ret   
  ```
- 重定位入口(Relocaltion Entry),即表的条目
- 重定位入口中的offset要被重定位的段中的位置
- 高24位表示在符号表中的下标（找到符号），如果符号类型是未定义，就返回未定义错误
- `address_of_call + offset + length_of_call`(调用指令的长度)

### 符号解析

- 重定位的过程伴随着符号的解析过程。重定位过程中，每一个重定位入口都是对符号的引用。
- 对某个符号的引用进行重定位时，需要确定符号的目标的地址。
- 全局符号表：链接时，所有目标文件组成的的全局符号表 
- `readelf -s a.o`查看符号表



### 指令修正方式

- 对于32位x86 平台的ELF文件重定位入口：
  
  - 绝对近址32位寻址
  - 相对近址32位寻址
    - S+A-P等到的相对近址32位寻址是距离被修正位置的地址差，即调用指令调用地址，是该指令下一条指令的起始地址+偏移量
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-25-09-11-31.png
  width=490px>
  </center>
  
  ```cpp
    Offset     Info    Type            Sym.Value  Sym. Name
    0000000a  00000501 R_386_32          00000000   .rodata
    0000000f  00000a02 R_386_PC32        00000000   printf // 00000a + A -P
    0000002b  00000c01 R_386_32          00000000   i //高 24位00000c+A 绝对地址修正
    00000034  00000902 R_386_PC32        00000000   foo
  ```
  
- 重定位位中的偏移如何最终成为虚拟地址的？[这一篇博客讲的很详细](http://blog.chinaunix.net/uid-30546860-id-5589966.html)

- 由此可验证info的高24位是符号在符号表中的下标。(重定位表中为什么要和符号表相关连呢？ 因为重定位表只是能指定什么地方需要被重定位，但需要被置换成什么数值，这个是由符号表决定的)。

- A = 保存在被修正位置的值(例如本例中printf重定位处的值是0xfc ff ff ff)（就是链接之前的地址，比如未初始化的变量就是00000000）

- P = 被修正的位置(相对于段开始的偏移量或者虚拟地址)，通过r_offset+段开始的值 其实就是汇编指令中指令地址

- S = 符号的实际地址， 即由r_info的高24位指定的符号的实际地址



绝对地址修正的地址就是该符号的实际地址

相对寻址修正后的地址为符号距离被修正位置的 **地址差** 

## COMMAN块

- 关于符号
  - 两个或者两个以上强符号不一致
  - 有一个强符号，其他都是弱符号 出现类型不一致
  - 两个或者两个以上弱符号不一致
- 将全局未初始化的值作为弱符号处理（因此需要放到COMMAN块）
- 不同目标文件需要的COMMAN块不一致时，以最大的那一块为准
- 有一个强符号，其他都是弱符号 出现类型不一致， 以强符号为准
- 如果有弱符号大小大于强符号，则会出现警告
- 因为弱符号（未初始化全局变量大小不定）不能分配空间，因此需要放到COMMAN块， 然后最后以最大的COMMAN块为主
- 通过了解链接器处理多个弱符号的过程，我们可以想到，
  - 当编译器将一个编译单元编译成目标文件的时候，如果该编译单元包含了**弱符号(未初始化的全局变量就是典型的弱符号)，那么该弱符号最终所占空间的大小在此时是未知的，因为有可能其他编译单元中该符号所占的空间比本编译单元该符号所占的空间要大。所以编译器此时无法为该弱符号在BSS段分配空间,因为所须要空间的大小未知**。但是链接器在链接过程中可以确定弱符号的大小，因为当链接器读取所有输入目标文件以后，任何-一个弱符号的最终大小都可以确定了，所以它可以在最终输出文件的BSS段为其分配空间。所以总体来看，未初始化全局变量最终还是被放在BSS段的。
- 如果不以Common块为准，那么未定义的全局变量会被认为是强符号

## C++相关问题

### 消除重复代码
 模板：模板的本质类似于宏

- C++中模板在一个单元被实例化时，它是不知道自己是否在别的编译单元也被实例化了。因此实例化同一个类型会造成重复代码
  - 例如模板函数add<T>() int和float，这时我们可以将每种实例代码单独放到一个段，如果多个编译单元有相同的实例，就与之合并
    - 如果生成重复代码非常浪费空间以及容易出错，效率低
    - 这时可以生成不同的模板代码单独存放在一个段，如果其他编译单元有相同类型，就合并到一个段
    - GCC把这种段称之为LINK_once VISUAL C++称为COMDAT
  - GCC把这种最终需要合并段称为Link Once，段名为gnu.linkonce.name
- 对于虚函数和外部内联函数也类似
  - 一个含有虚函数的类来说，每一个对象有一个与之对应的虚表，编译器会在多个用到该类的编译单元生成多个虚表，造成代码重复。这时也可以**将虚表放到同一个指定段**
  - 外部内联函数也类似处理,编译阶段就展开了
  - 这种问题是相同名称的段可能拥有不同的内容，由于不同的编译单元使用了不同的编译器版本或者优化
- **函数级别连接**
  - `-ffunction-sections`和 `-fdata-sections` 两个选项的作用就是将每个函数或者变量保存到独立的段中
  - 会导致编译很慢，因为要计算各个函数之间的依赖
  - 可以让不使用的函数不进行链接。

### 全局构造和析构

- Linux系统程序的入口是_start 这个函数是Linux系统库Glibc的一部分
- ELF文件定义了两种特殊段
  - .init 保存的是可执行指令。构成了进程的初始化代码。在调用main之前，Glibc的初始化会安排执行这个段中代码
  - .fini 该段保存着进程终止代码指令。因此main函数正常退出时，Glibc会安排执行这个段中的内容

### C++与ABI
如果想两个编译器编译的目标文件能被同一个链接器链接，这时需要符号修饰标准，变量的内存方式相同，函数的调用方式相同等等，把这些和二进制兼容性相关的内容称为ABI（Application Binary Interface）

- 二进制兼容很难做到目前两大派系 Visual c++ 和GNU阵营的GCC（采用intel Itanium C++ ABI标准）
  - 继承类体系的内存分布，如基类，虚基类在继承类的位置
  - 指向成员函数的指针的内存分布
  - 如何调用虚函数，vtable的内容和分布形式 vtable在对象中的位置
  - 模板如何实例化
  - 外部符号的修饰
  - 全局对象的构造与析构
  - 标准库细节，RTTI（Runtime Type Identification）如何实现，RAII


## 静态链接库

- 程序如何使用操作系统的API？ 使用语言库

- 静态库可以简单的看成一组目标文件的集合。目标文件压缩打包之后形成的文件。比如Linux中常用的C语言静态库/usr/lib/libc.a
- 使用`ar -t libc.a`查看静态库文件中目标文件组成
  - `ar -x libc.a`解压
- 第一步编译成一个汇编文件，然后as将汇编文件生成目标文件，最后调用collect2完成链接
- 静态库中一个目标文件只包含一个函数，因为链接时是以目标文件为单位的，如果多个函数都在目标函数中会造成浪费

## 链接过程控制
- 内核驱动程序需要指明：虚拟地址，段的名称，段存放顺序等
- 链接过程需要确定
  - 使用哪些目标文件
  - 使用哪些库文件
  - 是否在可执行文件中保留调试信息
  - 输出文件格式（可执行还是动态链接库）



## 链接控制脚本

- 控制链接器的三种方法
  - ld命令 ld -o ld -e等
  - 将链接指令放在目标文件里面。
  - 通过链接控制脚本


- 自己写一个链接脚本

### 最小的程序
```c
char* str = "hello world\n";

void print(){
    asm("movl $13, %%edx \n\t"
        "movl %0, %%ecx\n\t" //为啥是%0 占位符 “%0”和“%1”代表指令的操作数，称为占位符，内嵌汇编靠它们将C语言表达式与指令操作数相对应。
        "movl $1, %%ebx\n\t" //写文件句柄（描述符为1）
        "movl $4, %%eax\n\t"
        "int $0x80 \n\t"
        ::"r"(str):"edx","ecx","ebx");  //str表示为输入

        //ebx存储描述符 stdout 0

}

void exit(){
    asm("movl $42,%ebx \n\t"
        "movl $1,%eax \n\t"
        "int $0x80 \n\t");
}

void nomain(){
    print();
    exit();
}
```
- `gcc -c -fno-builtin tinyhelloworld.c`
- `ld -static -e nomain -o tinyhelloworld tinyhelloworld.o`

- 注意：ecx是表示buffer表示要写入的缓冲区地址 使用%0
  ```c
  __asm__ __volatile__ ("movl %1,%0" : "=r" (result) : "r" (input));
  ```
- “movl %1,%0”是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，内嵌汇编靠它们将 C 语言表达式与指令操作数相对应。
- 指令模板后面用小括号括起来的是 C 语言表达式，本例中只有两个：“result”和“input”，他们按照出现的顺序分别与指令操作数“%0”，“%1，”对应； 注意对应顺序： 第一个 C 表达式对应“%0”； 第二个表达式对应“%1”，依次类推，操作数至多有 10 个，分别用“%0”，“%1”….“%9，”表示。

- result”前面的限制字符串是“=r”，**其中“=”表示“result”是输出操作数**，“r”表示需要将“result”与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而不是“result”本身，**当然指令执行完后需要将寄存器中的值存入变量“result”，**从表面上看好像是指令直接对“result”进行操作，实际上 GCC 做了隐式处理，这样我们可以少写一些指令。

- “input”前面的“r”表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。

- 限制字符必须与指令对操作数的要求相匹配，否则产生的汇编代码将会有错，读者可以将上例中的两个“r”，都改为“m” (m，表示操作数放在内存，而不是寄存器中)，编译后得到的结果是：

`movl input, result`

- 很明显这是一条非法指令，因此限制字符串必须与指令对操作数的要求匹配。例如指令movl 允许寄存器到寄存器，立即数到寄存器等，但是不允许内存到内存的操作，因此两个操作数不能同时使用“m”作为限定字符。


### 使用ld链接脚本
```c
-T：-T 参数表示指定链接脚本，用户可以通过 ld -T file 来指定使用自己的链接脚本，而不使用系统默认的，在一些特殊的场景中适用。
@file: 从文件中读取命令行参数，而不是手动指定，通常在脚本编程时使用这种做法。
-e entry、--entry=entry：这两个命令是同等效果，显示地指定程序开始的位置，通常情况下，需要指定程序内部的符号，如果给定的参数不是一个符号，链接器会尝试将参数解析成数字，表示从指定的地址开始执行程序。
-EB、-EL：指定大小端，这会覆盖掉系统默认的大小端设置。
-L、--library-path=searchdir：指定搜索的目录
-l ：链接指定的库，库名通常是 libname.a 或者 libname.so，使用该参数时去掉库的前后缀，即 -lname
-o output、--output=output：指定输出文件名
-s、--strip-all：丢弃可执行文件中的符号，以减小尺寸。
-static：不使用动态库，静态地链接
-nostdlib：默认情况下链接标准库，该参数显示地指明不链接标准库。
-shared：创建一个动态库
```

```c
//lds脚本
ENTRY(nomain)
SECTIONS{
    . = 0x08048000 + SIZEOF_HEADERS;/*设置当前虚拟地址。SIZEOF_HEADER头文件大小*/
    tinytext : {*(.text) *(.data) *(.rodata)}
    /DISCARD/ : {*(.comment)}
}
```
### ld链接语法简介
- 命令语句
  - ENTRY
  - SECTIONS
    ```c
    SECTIONS
    {
        secname : {contents}
    
        contents可以写为
        filename(sections);// filename *为通配符
        
    }
    ```
    - secname表示段名
    - 
- 赋值语句
- 注释 /**/
- 



### BFD库
- 通过统一的接口来处理不同的目标文件格式。把目标文件抽象成一个统一的模型
- 安装binutils-dev 
  ```cpp
  #include "bfd.h"
  ```