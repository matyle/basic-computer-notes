## 为什么要动态链接

不是有了静态链接了吗？
- 缺点1：内存和磁盘空间浪费严重，多个程序运行，每个程序都有公共的库，这样就会造成浪费
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-30-09-19-45.png
  width=390px>
  </center>

  - 比如这个例子程序1和程序2 公用lib.o，生成可执行文件之后，两个程序都含有lib.o这样就会造成磁盘空间浪费，而一旦运行则会运行两个副本在内存中，造成内存浪费


- 缺点2 ：程序开发和发布
  - 静态链接中，例如lib.o进行了一点小的bug修复修改，则程序1必须要重新链接，连接然后发布给用户更新，十分不便。更新任何一个模块都需要全部重新链接

### 动态链接

  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-06-30-09-14-39.png
  width=390px>
  </center>
什么是动态链接？

实际上是把共享对象文件(.so本质也是目标文件)在运行时才链接。也就是说程序a和程序b都可能用同一个lib.o。

- lib1.so进入内存之后。这时想想a和b数据应该是不共享的。不是所有指令都应该共享
- 静态链接时内存中有两个lib1.o，就不存在共享冲突
- 动态链接
  - 基本思想：把链接推迟到运行时进行。把程序按模块拆分成几个部分，运行时链接
  - 在内存和磁盘中只保留一份，优点是节省内存，减少物理页面的换入换出（节约了页面），提高cpu缓存命中率。不同进程间的数据和指令都在一个共享模块上面。
  - 更新更加方便：升级程序时只需要覆盖旧的目标文件，无需重新链接，下次程序运行时自动装载到内存并链接。
  - 可扩展性和兼容性：动态选择加载各种模块，称为插件。中间层消除不同平台之间依赖的差异性。

动态链接的问题：

- 某个模块不兼容会导致整个程序无法运行


### 动态链接基本实现
- 比静态链接复杂，因为内存管理，内存共享，进程线程机制在动态链接下有轻微的编号
- ELF动态链接文件称为动态共享对象（DSO dynamic shared object），因此后缀是so
- Windows叫DDL，动态链接库

## 动态链接例子
- `gcc -fPIC -shared -o Lib.so Lib.c` 生成一个动态链接文件
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-07-01-15-55-12.png
  width=450px>
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;"></div>
  </center>
  
- 共享对象的最终装载地址在编译时是不确定的。

####  动态链接程序运行时地址分布

静态链接映射整个文件。

## 地址无关代码

### 固定装载地址的困扰
- 静态共享库（不是静态库）：将程序的各种模块统一交给操作系统管理，在某个特定地址划分出地址块，为已知模块预留空间
  - 会导致地址冲突
  - 升级必须保持全局函数和变量地址不变。如果更改就得重新链接程序

### 装载时重定位

静态链接是链接时重定位，现在称为装载时重定位。

- 为了解决共享对象所存在的问题
- 指令没办法共享：因为装载时重定位需要修改指令。因为每个程序装载地址不同，就会导致模块地址不同，因此不能直接共享。

### 地址无关代码

-fPIC开启地址无关代码

- 装载时重定位最大缺点是：指令部分没办法在多进程中共享
- 我们希望共享模块的指令地址不要因为装载地址的改变而改变
- 解决这个的前提：数据本身不共享。因此我们可以将要修改的指令与数据放在一起，指令部分可以保持不变。这就是**地址无关代码（PIC）技术**

#### 内部引用和外部引用

- 又可以分为指令引用和数据访问
  - 第一种：模块内部的函数调用，跳转等。
  - 第二种：模块内部的数据访问，如模块中定义的全局变量，静态变量
  - 第三种：模块外部的函数调用，跳转等。
  - 第四种：模块外部的数据访问，如模块中定义的全局变量。
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-07-01-16-20-01.png
  width=450px>
  </center>
  

- 类型1：模块内部的函数调用
  - 相对位置固定，无需重定位
<center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-07-01-16-32-52.png
  width=490px>
</center>

- 类型2：模块内部数据访问
  - 利用PC值然后加上偏移量访问相应变量地址
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-07-01-16-33-56.png
  width=490px>
  </center>
  

- 模块间数据访问
  - 其他模块中的变量目标地址需要装载时才能确定， 因此这些变量和模块装载地址相关
  - 代码地址无关基本思想：把地址相关部分指令放到数据段里面
  - 因此elf在数据段里面建立一个**指向这些变量的数组，全局偏移表（GOT）**

- 模块间调用和跳转
  - 同样利用GOT，GOT中保存目标函数的地址
  - 先得到PC地址，然后加上一个偏移得到函数地址在GOT中的偏移，然后间接调用
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-07-02-08-21-35.png
  width=450px>
  </center>

- fpic和-fPIC ：使GCC产生地址无关代码


### 共享模块的全局变量问题
  - 定义在模块内部的全局变量的情况：全部当做类型四，存放在GOT中。
  - 因为有时无法确定是模块内部的全局变量还是跨模块的，因此统一当做跨模块的情况


### 数据段地址无关性
- 对于数据段：每个进程都有一份独立副本，并不担心被进程改变。因此可以装载时重定位
- 装载时重定位：每个进程如果使用同一个动态链接库，需要对其所有部分拷贝，包括共享的指令。否则每个进程装载地址不同，就会导致指令段的地址不同导致无法共享


## 7.4 延迟绑定（PLT）
  - 函数第一次用到才绑定（符号查找，重定位）
  - 没有使用则不绑定
  - 使用PLT方法实现。
<center>
    <img style="border-radius: 1.125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
    src=img/2021-07-02-08-57-55.png
width=450px>
</center>


## 7.5动态链接相关结构

### .interp段
- 装载完之后控制权实际还不能交给可执行文件，需要给动态链接器ld.so
- ld.so的位置由.interp决定，interpreter(解释器) 
- .interp中保存的一串字符串是可执行文件的路径


### .dynamic段
- .dynamic段保存的是动态链接器所需要的基本信息。包含依赖哪些共享对象，动态链接表的位置，动态链接重定位表的位置，共享对象初始化代码的地址等。
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-07-02-09-04-42.png
  width=450px>
  </center>
  
- .dynamic段类似于静态链接中的ELF头文件


### 动态符号表
- 与静态链接中.symtab对应，动态链接表.dynsym表，动态符号表
- 导入函数：引用了Lib.so的函数
- 导出函数：从Lib.so的角度看，它的函数给其他模块使用是导出函数

### 动态链接重定位表

- 在动态链接中，导入符号的地址需要在运行时才确定。，所以在运行时才将这些导入符号的引用修正，即需要重定位
- 动态链接中重定位相关结构
  - .rel.dyn相当于rel.text 以及.rel.plt相当于.rel.data
  - 如果以IPC方式，函数符号会存放咋.rel.plt中，并且.rel.plt修正的位置存放在.got.plt中
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-07-02-09-19-03.png
  width=450px>
  </center>

### 动态链接时堆栈初始化信息

- 堆栈中保存了辅助信息数组:位于环境变量指针后
  ```c
  typedef struct{
      uint32_t a_type;
      union{
          uint32_t a_val;
      }a_un
  
  }Elf32_auxv_t
  ```
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-07-03-08-38-36.png
  width=450px>
  </center>
  
  
- 查看堆栈内容 (int)*p = (int*) argv 取argv的地址
  <center>
      <img style="border-radius: 1.125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"
      src=img/2021-07-03-08-36-00.png
  width=450px>
  </center>
  


## 动态链接的步骤和实现

### 动态链接器自举
- 动态链接器不能依赖于任何共享对象
- 本身所需要的全局和静态变量的重定位由它本身完成
- 在完成重定位之前，全局和静态变量的变量，甚至函数都不能调用。

### 装载共享对象

- 可执行文件和链接器本身的符号表合并到一个表，称为全局符号表

### 重定位和初始化

### Linux动态链接器实现

- execve系统调用被装载到进程的地址空间的程序，以及内核处理可执行文件
- 对于动态链接，装载完ELF从内核返回后回到用户空间，把控制权交给程序的入口
  - 静态链接：程序入口就是ELF头文件的e_entry指定的入口
  - 动态链接：分析.interp段，将动态链接器映射到进程地址空间，把控制权交给动态链接器

### 几个函数
- dlopen()函数，打开一个动态库，将其加载到地址空间，完成初始化
- dlsym()函数，找到所需要的符号
- dlerror() 判断是否调用成功
- dlclose() 卸载已加载的模块