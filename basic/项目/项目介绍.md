说话的时候磕磕巴巴
可以深讲一下自己懂的东西，对自己实际写的东西或者熟悉的不要浅尝而止。
不懂的不要装懂，不会的不要说。
自信的一点，说话太磕磕巴巴了

### web介绍项目

- 项目背景
  - 学了《unix网络编程》和Linux书籍之后，对操作系统方面很感兴趣，同时巩固学的知识，做的一个webserver项目。
  
- 项目特点：
  
  - 程序使用多线程多Reactor模型，并使用多线程提高并发度。
  - 为避免线程频繁创建和销毁带来的开销，使用线程池，在程序的开始创建固定数量的线程。使用epoll作为IO多路复用的实现方式。
  - 避免资源泄漏，利用C++的RAII手法封装了实现使用的资源，其中包括TCP连接中的socket描述符，多线程中的互斥量和条件变量等。
  - 使用C++的智能指针方法管理指针，以及仿函数设置事件回调函数
  - 当主线程把新连接分配给了某个SubReactor，该线程此时可能正阻塞在多路选择器(epoll)的等待中，怎么得知新连接的到来呢？这里使用了eventfd（异步唤醒）进行异步唤醒，线程会从epoll_wait中醒来，得到活跃事件，进行处理。
  
- 项目构架
  - 多线程reactor模型（one loop per thread)(主线程loop负责接收连接，其他线程处理客户端连接，使用轮询方式将对应的fd挂在哪个loop。
  - 日志模块
  - 数据库连接池
  - http实现登录注册（业务）

- 什么是one loop per thread

  - per thread per epoll 
  -  epoll+线程池

  第一种：只有一个epollA（线程A）除了负责监听一个socket，开始监听到新的客户端连接他们的socket分别为B，C，D

  - BCD还是挂在epollA中，即epoolA除了接收新连接，还要处理BCD客户端的数据（Redis 就是这种单线程模型。）
  - BCD挂在新的epoll中，分别为epollB，epollC，epollD，然后后面的socket使用轮询方式

  每个线程的循环结构为（即loop中，如果有事件发生则会调用channel中的回调函数）：

  ```cpp
  while(!m_quit)
  {
    //步骤1 epoll_wait 或者select
    epoll_or_select();
    //步骤2 处理IO时间
    handle_io_event();
    
    //步骤3 做其他事情
    handle_other_thing();
  }
  ```

  

- 什么是RAII？优点是什么？

  普通资源获取后，如果没有考虑到程序执行过程中的异常或者错误，导致资源没有回收，从而资源泄漏。

  - RAII 资源获取即初始化。在对象作用域内，利用C++类的构造函数初始化资源，对象出作用域时利用析构函数回收资源。
  - 优点：防止资源泄漏

### 项目难点

- poll和epoll的使用
  - epoll中ET和LT的读写问题
  - LT的写事件问题
- 多线程中对象生命期管理
  - mutex作为对象的成员 不能保护析构
  - 对象析构 -- 使用智能指针
  - 使用shared_ptr中遇到的问题，循环引用---后面配合weak_ptr
  - 构造函数回调需要传递this指针，导致其他线程读到了未完成析构的对象
- 
- 从poll返回到再次调用poll(2)阻塞 称为一次事件循环

- 说一说项目的优点


- 具体方式

- 不熟悉的地方
  - http协议不熟悉。
  - tcp协议说的不好

不懂的问题



### TCP协议中的问题

阻塞和非阻塞描述符

- 阻塞

  **输出操作，包括****write****、****writev****、****send****、****sendto****和****sendmsg****共****5****个函数。对于一个****TCP****套接字，内核从应用进程的缓冲区到套接字的发送缓冲区复制数据。对于阻塞的套接字，如果其发送缓冲区中没有空间，进程将被投入睡眠，直到有空间为止。

  阻塞模式下一直write到接收端的**套接字接收缓冲区**和发送端的**套接字发送缓冲区**都满的情况才会阻塞

- 非阻塞

  非阻塞套接字情况下，write的工作方式：**对于一个非阻塞的TCP套接字，如果发送缓冲区中根本没用空间，输出函数将立即返回一个EWOULDBLOCK错误。如果发送缓冲区中有一些空间，返回值将是内核能够复制到该缓冲区的字节数。这个字节数也成为“不足计数”。——UNPv1**

  非阻塞模式情况下有可能是发送端发送过程的第二步较慢，造成发送端的套接字发送缓冲区很快写满，而接收端的套接字接收缓冲区还没有满，这样write就会仅仅因为发送端的套接字发送缓冲区满而返回错误(准确的说的套接字发送缓冲区的可用空间小于write请求写的字节数

问题来了，我的服务器使用非阻塞描述符，如果发送大量数据，发送缓冲区存不下怎么办？这时又不能阻塞在那里

- 在EPool或者poll中添加监听写事件，当缓冲区可写时就通知，多写几次
  - 如果是LT模式，如果缓冲区一直可写那么就会一直通知就绪事件
  - ET模式则只会通知一次就绪事件

- sudo tcpdump -nt -i en0  port 1234



## myCRT

- malloc实现：堆初始化，管理空闲块，选择空闲块，分配空闲块，释放空闲块
