## 显示内存管理（手动管理）

野指针：内存单元已释放，但是指向它的指针还在使用。这些内存可能重新分配给程序，导致无法预测的错误

重复释放：释放已经释放过的内存单元。

内存泄漏：不再需要使用的内存单元没有被释放





## 智能指针

### unique_ptr移动语义

- 不能被拷贝

```cpp
unique_ptr<int> up1(new int(1));
unique_ptr<int> up2 = up1;//错误，不能赋值拷贝
unique_ptr<int>up3(up1);//不能拷贝
unique_ptr<int> up4 = move(up1);//移动语义 up4是数据的唯一的unique_ptr

up1.reset();//正确
up3.reset();//显式释放内存
cout<<*up3<<endl;//使用野指针 运行时错误
```



### shared_ptr（一根钢丝绑在对象上）

- 拷贝和赋值：引用计数
- get()小心使用，如果指针指针释放了其对象，返回的指针指向的对象也就消失了

```cpp
shared_ptr<int> sp1(new int(22));
shared_ptr<int> sp2 = sp1;//引用计数+1为2
weak_ptr<int> wp = sp1;//引用计数不变

shared_ptr<int> sp3 = wp.lock();//尝试提升
if(sp3!=null) //提升成功
{
  ...
}
```

### weak_ptr（一丝头发绑在对象上）

- 一些规则：
  - `weak_ptr`指向`shared_ptr`，引用计数不变
  - 不管理对象的生死，只能感知对象的生死
  - 如果对象还存在，则能够提升为`shared_ptr`,否则提升失败
  - `wp.lock();`尝试提升
- 常用函数
  - `wp.lock()`//如果expired返回false则返回指向w的shared_ptr对象，否则返回空的shared_ptr(引用计数为0，说明对象不存在了)
  - `wp.expired()`//检查引用计数，如果为0返回true，否则返回false
  - wp.use_count()//查看引用计数
  - wp.reset()，wp置空



##C++与垃圾回收（GC）

c++支持部分垃圾回收

### 垃圾回收的方式

- 基于引用计数
  - 实现简单，且不会暂停程序，副作用小
  - 但是由于引用计数带来的额外开销大，使用较少

- 基于跟踪处理

  - 标记-清除（mark-sweep）

    步骤：

    - 从根对象查找引用堆空间，在堆空间做标记
    - 被标记的就是可达对象（活对象）。
    - 第二步sweep扫描堆空间，没有被标记的就会被回收

    缺点：

    - 出现大量碎片，因为活对象不能被移动

  - 标记-整理

    - 标记时将活对象向左靠奇，解决内存碎片
    - 但是整理过程中需要对所有引用的堆内存更新

  - 标记-拷贝

    - 堆分成了from和to两个部分。只从from堆空间分配内存。



```cpp
int main()
{
  int *p = new int;
  p += 10;//移动指针 可能导致垃圾回收
  p -= 10;//回收原来指向的内存
  *p = 10;//再次使用原本相同的指针则可能失效
}
```

移动指针这种情况该不该回收呢？回收之后程序再用怎么办？





### 最小垃圾回收支持

