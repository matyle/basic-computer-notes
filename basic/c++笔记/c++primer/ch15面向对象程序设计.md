
## 概述

- 继承
  - 派生类构造函数不能直接初始化基类的成员，需要调用基类的构造函数
- 虚函数
    - 有虚函数就需要，定义一个虚析构函数
- 动态绑定
  - - RTTI（RunTime Type Information）：运行时可提供类型的信息，其实就是打开了才可用 dynamic_cast ，以及取得多态对象的 typeid。


- 继承与静态成员
  - 在整个继承体系中，静态成员只存在该成员的唯一定义，只存在唯一实例，不论有多少个派生类


- 派生类的声明不包含派生列表
- 用作基类的类必须定义之后才能被继承。
- 防止继承的发生，关键字final
  ```cpp
  class NoDerived final{}
  class Last final:public Base{}
  ```



### 类的转换与继承

- 引用和指针绑定到一个对象上，则引用或者对象的类型一致。或者对象类型含有一个可接收的const类型转换规则


- 静态类型和动态类型
  - 静态类型是编译时总是已知的。
  - 动态类型直到运行时调用函数知道

- **不存在基类向派生类的隐式类型转换**
- 对象之间不存在类型转换
  - **派生类向基类的自动类型转换只对指针或者引用类型有效，在派生类类型和基类类型不存在这种转换** 只能调用基类的构造函数，拷贝/移动构造函数，因此派生类的部分会被切掉


## 虚函数
- 对虚函数的调用可能在运行时才被解析
- 多态
- 派生类的虚函数
  - 覆盖时，可以再一次使用virtual关键字
  - 覆盖时，形参类型必须与基类一致
  - 覆盖时，返回值类型必须与基类一致。（例外情况是返回类本身的引用或者指针时，这个规则无效）
- **final和override说明符**
  - `override`关键字说明派生类的虚函数，更加清晰的发现错误（形参不匹配），因为我们说了派生类的虚函数的形参类型必须一样，如果不一样编译器会认为这是两个独立的函数
  - `final`关键字使成员函数不允许被覆盖，任何尝试覆盖该函数的操作都将引发错误


- 虚函数与默认实参
  - **默认实参由静态类型决定**

- 回避虚函数的机制：使用作用域运算符


## 抽象基类
接口
- 纯虚函数
  ```cpp
  class A
  {
      double foo(int)const = 0;//纯虚函数
  };
  ```
- 定义纯虚函数的类都是抽象基类，不能直接创建一个抽象基类的对象
- 可以为纯虚函数提供定义，但是必须在类的外部

## 访问控制与继承
- 受保护的成员(protect):声明希望与派生类共享但不想被其他公共访问使用的成员


- 公用，私有，受保护继承
  - 这几个继承都不影响派生类的访问权限
  - 控制的是派生类用户（包括派生类的派生类在内）对于基类成员的访问。
  ```cpp
  Pub_Derv d1;//公共继承
  Pri_Derv d2;//私有继承
  d1.pub_mem();
  d2.pub_mem();//错误 pub_mem在派生中是私有的。
  ```


## 构造函数与拷贝控制

### 虚析构函数
- 带有虚函数的基类，通常应该带有一个虚析构函数。
  - 如果没有，delete一个指向派生类对象的基类指针会出现未定义的行为。
  - 定义了虚析构函数，会阻止合成移动操作




```cpp
class Base{...};

class D:public Base
{
public:
    D(const D& d):Base(d) //拷贝基类成员
    D(D &&d):Base(std::move(d));//移动基类成员
    D& operator=(const D& rhs)
    {
        Bass::operator=(rhs); //赋值基类成员
        //赋值派生类成员
    }
};
```

## 继承中的类作用域 p549
- 名字查找先于类型检查
  - 会现在对应的变量或者函数名，然后就停止查找。然后就检查类型。因此子类里面重写一个函数会覆盖基类的函数。
  - 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类的名字




